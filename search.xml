<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常见问题总结]]></title>
    <url>%2F2019%2F11%2F10%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[勿忘初心。 函数参数的命令，比如一个ajax请求，用res作参数传递，那么下面函数内参数不要再用res命名，以免混杂，其他同理！！！ 公共的参数可以单独写到一个文件内，增加可扩展性 注意异步的顺序，所以逻辑上，把下一步的执行逻辑写在当前异步内，不过这样会一层套一层，所以可以使用Promise 扫码的时候，单选框的值会自动变换成下一项 splice处理数组，数组项位置会改变，如果for循环，遍历数组并删除数组的时候，容易会跳过一项，只是可以数组倒着遍历，解决该问题 forEach,map 无法通过return,continue,break跳出循环！ sass类名用-，eslint检测出错！ 函数自身递归调自己时候需要返回，因为调自己的时候作用环境发生改变 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function findTarget(source, url) &#123; if (source &amp;&amp; source.length) &#123; for (let item of source) &#123; if (item.url === url) &#123; return item; &#125; else if (item.children &amp;&amp; item.children.length) &#123; let target = findTarget(item.children, url); if (target) &#123; return target; //这里return &#125; &#125; &#125; &#125;&#125;let test = [ &#123; url: 'dada', key: 1, children: [ &#123; url: 'a', key: '1.1', children: null &#125;, &#123; url: 'b', key: '1.2', children: null &#125; ] &#125;, &#123; url: 'c', key: 2, children: null &#125;, &#123; url: 'd', key: 3, children: [ &#123; url: 'e', key: '3.1', children: null &#125;, &#123; url: 'f', key: '3.2', children: null &#125; ] &#125;];console.log(findTarget(test, 'f')); 9.解构赋值和Object.assign都只能浅拷贝 1234let obj = [&#123;a: 1&#125;, &#123; b: 2&#125;];let copyObj = [...obj];copyObj[0].a = 2;console.log(obj); //[&#123;a: 2&#125;, &#123; b: 2&#125;] 10.generate函数中yeild不能用到forEach、map中，不能用在回调函数中 11.Switch开关值通过checked属性控制 12.git提交代码注意先pull]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F11%2F09%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[勿忘初心。 git init 初始化一个git仓库 git status 查看仓库状态，比如某某文件修改，可通过git diff进行查看改动的地方 git add 文件名 添加某文件到暂存库 git commit -m &quot;本次commit的描述信息&quot; 提交暂存库文件到版本库，-m后跟本次提交的描述 git diff 文件名（可选，不填则为所有文件的差异） file为要查看文件名(可选)，查看本地改动文件差异，不甜的话，查看工作区所以改变的地方 git log 查看提交记录 (--pretty=oneline()) HEAD表示当前当前版本 git reset --hard HEAD^ 回退到上一版本 git reset --hard HEAD^^ 回退到上上版本 git reset --hard commit-id（commit生成的id,不用全填，前几位即可） commit-id是版本提交生成的id,回退到那次commit git reflog 查看操作记录，包括回退记录 git checkout -- file file为文件名，把当前工作区的更改回退回去(file 必填),文件如果不小心删错了，可以用本操作恢复回去（file必填） git reset HEAD &lt;file&gt; file可填，文件名，把提交到暂存区的文件回退回去,file不填回退所有已提交到暂存区的文件 git checkout -b 分支名 创建分支并切换到该分支上 git branch 分支名 创建分支 git checkout 分支名 切换到该分支上 git branch 列出所有分支 git merge 分支名 合并分支 git merge --no-ff -m &quot;合并描述&quot; 分支名 –no-ff参数，表示禁用Fast forward，如果master分支没有更新，直接合并的分支内容，会进行快进模式，然后就没有合并的记录，所以添加 --no-ff以便添加一次合并记录后续可查看 git branch -d 分支名 删除分支 git log --graph 查看分支合并图 当你在开发分支开发东西时，但主分支急需改bug，但你开发分支东西刚开始做，所以不能提交，按以下操作git stash 可以把当前工作现场保留起来 git stash list 查看已保留现场 git stash apply 现场名前缀（eg:stash@{0}） 把之前的现场还原回去 git stash drop 删除之前的现场 git stash pop 建议用，恢复并且把之前的现场记录删除掉 远程分支git remote 查看远程库的信息 git remote -v 查看远程库的详细信息 git push origin 分支名 提交分支内容到远程分支 git push origin 本地分支名：远程分支名 将本地新创建的分支推送到远程，如果远程分支名没有则会创建 git checkout -b 本地起的分支名 origin/远程分支名 拉取远程新增的分支到本地 git pull origin 分支名 拉取对应分支更新 git branch -r 查看远程新增分支，红色的，可以先git pull一下 git fetch -p 远程把分支删除了，本地和远程同步下 git push origin --delete 分支名 删除远程分支]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他常用命令]]></title>
    <url>%2F2019%2F11%2F09%2F%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[勿忘初心。 ctrl + shift + t 恢复最近删除的网页，(vscode编辑器中也可以) alt + 向左箭头 返回到这个方法被调用处，（刚才被点击处）]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>浏览器、编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建前端工程遇到的问题]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[勿忘初心。 babel-plugin-transform-class-properties 解决react中方法用箭头函数，报错问题。.babelrc中plugins添加如下123"plugins": [ ["transform-class-properties"]] babel-preset-react babel支持编译react，.babelrc注意presets中添加&#39;react&#39;值 babel-plugin-dynamic-import-webpack 支持动态import,.babelrc中plugins添加如下123"plugins": [ ["dynamic-import-webpack"]] 项目中添加antd支持babel-plugin-import 解决antd组件按需加载，.babelrc中plugin属性中添加如下内容123456789&#123; "plugins": [ ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" // `style: true` 会加载 less 文件 &#125;] ]&#125; babel-plugin-transform-runtime babel-polyfill支持es6API Generator .babelrc中plugins属性中添加如下内容12345678"plugins": [ ["transform-runtime", &#123; "helpers": false, "ployfill": false, "regenerator": true, "moduleName": "babel-runtime" &#125;]]]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-3-30日记]]></title>
    <url>%2F2019%2F03%2F30%2F2019-3-30%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人空间，请勿打扰 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-1-26日记]]></title>
    <url>%2F2019%2F01%2F26%2F2019-1-26%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人空间，请勿打扰 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clean-code]]></title>
    <url>%2F2019%2F01%2F26%2Fclean%20code%2F</url>
    <content type="text"><![CDATA[勿忘初心。 Array.includes 与条件判断一般情况可能存在某个值等于某项，需要我们用||去一个个补充上123456789/** * @description 判断水果类型 * @param &#123;string&#125; fruit 水果名 **/function test(fruit) &#123; if (fruit == "apple" || fruit == "strawberry") &#123; console.log("red"); &#125;&#125; 如果我们有更多水果12345678910/** * @description 判断水果类型 * @param &#123;string&#125; fruit 水果名 **/function test(fruit) &#123; const redFruits = ["apple", "strawberry", "cherry", "cranberries"]; if (redFruits.includes(fruit)) &#123; console.log("red"); &#125;&#125; Set与去重ES6提供了新的数据结构。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。数组去重12const arr = [1,2,3,2,3,5];const newArr = [...new Set(arr)];//[1,2,3,5] Array.from方法可以将Set结构转为数组。我们可以专门编写使用一个去重的函数123456789/** * @description 去重的方法 * @param &#123;Array&#125; array * @return &#123;Array&#125; 一个去重的数组对象 **/function unique(array) &#123; return Array.from(new Set(array));&#125;unique([1, 1, 2, 3]); //[1, 2, 3] 字符去重12let str = [...new Set("ababbc")].join("");console.log(str); //"abc"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-9日记]]></title>
    <url>%2F2018%2F12%2F09%2F2018-12-9%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人空间，请勿打扰 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-23日记]]></title>
    <url>%2F2018%2F10%2F23%2F2018-10-23%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人空间，请勿打扰 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-12日记]]></title>
    <url>%2F2018%2F10%2F12%2F2018-10-12%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[个人空间，请勿打扰 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimeText3配置]]></title>
    <url>%2F2018%2F09%2F30%2FsublimeText3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[勿忘初心。 我的默认Preferences中setting为 1234567891011121314151617181920&#123; &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.sublime-color-scheme&quot;, &quot;font_options&quot;: [ &quot;gdi&quot; ], &quot;font_size&quot;: 14, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;auto_close_tags&quot;: true, &quot;auto_complete&quot;: true, &quot;tab_size&quot;: 4, &quot;line_padding_bottom&quot;: 4, &quot;save_on_focus_lost&quot;: true, &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: true, &quot;theme&quot;: &quot;Default.sublime-theme&quot;&#125; 安装插件管理的Package Control打开View中的console（ctrl+`）然后输入如下代码 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 回车即可 我安装的插件 Emmet、less、sass、]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>sublimeText3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode自用插件]]></title>
    <url>%2F2018%2F09%2F30%2F%E6%88%91%E7%9A%84Visual%20Studio%20Code%2F</url>
    <content type="text"><![CDATA[勿忘初心。 VScode自己常用的插件 主题:Atom One Dark Theme 自动补齐标签:Auto Close Tag 自动重命名标签名:Auto Rename Tag 浏览器打开:view-in-browser sass支持： Sass todo高亮: TODO Highlight 文件图标显示: Material Icon Theme配置设置： 失焦保存开启（自动保存，文件下-&gt;）目前在用的编辑器，非常方便。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试用期工作总结]]></title>
    <url>%2F2018%2F09%2F30%2F%E8%AF%95%E7%94%A8%E6%9C%9F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[勿忘初心。 中心项目遇到的问题和自己获得心得体会: return 后要跟代码，不能换行 进度条，表单数据渲染，无法获取之前存好的表单值，因为页面销毁 事件，第一个默认参数是事件对象本身，箭头函数 筛选，对象的层层调用，最好先判断调用者是否存在，以免页面崩溃 站控项目遇到的问题和自己获得心得体会: 异步解决办法promise,resolve只能返回一个参数 深拷贝：在原来对象上拷贝一个新对象，改变其引用地址，从而不影响原有对象，JSON.parse(JSON.stringify()),无法拷贝对象属性值是方法的属性 单引号括起来单引号（很瓜) 页面交互时，需要控制的状态，例如一个人的信息，用对象保存，便于后续重置。 数据类型上这里很容易出问题，比如true，可能是字符串的’true’ 利用编辑器的快捷方式，便于开发，提高自己的效率 同事的建议和帮助 工作时，不需要把很多概念都去弄得很明白，先实现功能，在做的过程中，慢慢就都清楚了，不要过分去把时间耗在不必要的思考上，这些应该在下班之后花时间去考虑。 平时出bug，可以记录下来，以便以后忘记，重复出现。自己的误区 过分去追究细节，比如中心的项目，最开始就把各种地方都要看懂，大而全，反而容易把自己陷进去，和自己已有概念发生矛盾，思想执拗进去，后续再去查询，反而全部疏通了。自己的思考 学会转换一种想法，面对比较难的项目，对自己是挑战也是进步，面对别人对自己的要求，相应的即是对自己的重要，也是可以锻炼自己的机会，怎么赢难而上，方式方法。 转换自己焦虑，专注力。 不擅长表达，就把自己该做好的事情做好。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作第一月总结]]></title>
    <url>%2F2018%2F04%2F05%2F%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[勿忘初心。 离之前每天图书馆敲代码的日子突然画风一转变成了工作狗，而且我在写这个文章的时候，已经过了一个月了，这一个月发生了很多，比如说为了装xd，我的电脑被基友给清空了，一年学习的很多东西都没了，关键我还想不起是哪些没了，心累啊，面试总结一个、一些常用的demo例子，今日头条大佬的学习笔记也没了，可能还有很多我现在想不起来的，等用到的时候，怕是心累的一匹，现在就把自己这一个月经历的能想到的问题全部写一遍把，以便以后回过头来查看。第一周： 刚进公司，装环境，记得很多都装过了，自信心满满，然后到了配React环境那里，配不来啊，又要测试、又是sass编译，又是上线，各种bug，然后不弄了，觉得花时间在webpack配置上还是先看官方文档，webpack留给后面，先把React的所有特效全部弄一遍，熟悉了一遍当初视频的代码，然后官网文档，这是个特别好的东西，对理解React这块，然后文档越看越难，幸好把基础都过了一遍，然后卡壳到高级那里，然后就开始迷离的生活，然后同事在看React学习之道，我也开始拿起这本书，刷起来里面的代码来，然后，感觉自己写着就写偏了，谢谢我第一周遇到的东西，和问题。写了一个登录界面，需要ajax传递一些数据给后台一些接口，然后报错，就是不行，说本该是整型的数据传递，但传递过去的是字符，这里一脸懵逼，最后看尧哥新写的代码 1234567891011$.ajax(&#123; url: "https://art.ci.better8.cn/api/user/sms", method: "POST", data: &#123; "data": "&#123;\"mobile\":" + phone + ",\"type\":2 &#125;" &#125;, success: function (response) &#123; console.log("短信已发送"); timeout(60); &#125;&#125;); 用转义字符\” 解决了这个问题，这段代码是谷歌浏览器的一个插件自动生成的叫Postman,但是自己模拟接口报错，这里自己需要花时间解决一下。 第二周： 这周感觉也很闲，没做什么，就刷文档，后面尧哥给了一个好多多，关于学生学画画的app，手机介绍页面，这里自己特别高兴，但后面好像有悲伤的故事等着自己，这里有个东西学到了，那就是html中写两个div，一个里面放着pc的页面，一个放着移动端的页面，然后通过js判断，代码如下：123456789101112131415161718192021function isMobile()&#123; let ua = navigator.userAgent; let ipad = ua.match(/(iPad).*OS\s([\d_]+)/), isIphone = !ipad &amp;&amp; ua.match(/(iPhone\sOS)\s([\d_]+)/), isAndroid = ua.match(/(Android)\s+([\d.]+)/), isWeiXin = ua.match(/MicroMessenger/i), isMobile = isIphone || isAndroid || isWeiXin; if (isMobile) &#123; return true; &#125;else &#123; return false; &#125;&#125;$(function() &#123; let key = isMobile(); if (key) &#123; $('.mobile').css('display','block'); &#125; else &#123; $('.container').css('display','block'); &#125;&#125;); 以备以后查看，哈哈，这周没什么大问题 第三周： 哈哈，幸福生活来了，官网要弄，拿react写，具体写的时间星期二晚上开始写的，环境不会配，尧哥帮忙配好，后面这里要花时间去解决，官网react框架写的静态页面，遇到的问题，写好的页面，分辨率的问题，不同分辨率下，炸了，解决方案目前想到的是媒体查询+rem/em;另一种百分比，现在想到最靠谱的就是flex布局加margin/padding解决，目前在学习状态原生实现太多特效，要用state改！动画实现echart看看问题：1.&lt;button&gt;按钮中加入a便签，设置margin，hover时候会缩进，后续用代码现在不想敲字了，哈哈2.margin那个问题，自己第一个博客3.visted、link这两个css属性只能用到a标签上待补充]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识点总结]]></title>
    <url>%2F2018%2F03%2F06%2Fjs%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[勿忘初心。 基础知识原型 原型链作用域 闭包异步 单线程JS APIDOM操作Ajax事件绑定开发环境版本管理模块化打包工具运行环境页面渲染性能优化 先从几道面试题说起 JS中使用typeof能得到哪些类型？（JS变量类型） 何时使用=== 何时使用==？（强制类型转换） window.onload和DOMContentLoaded的区别？（浏览器渲染过程） 用JS创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号（作用域） 简述如何实现一个模块加载器，实现类似require.js的基本功能（JS模块化） 实现数组的随机排序 （JS基础算法） 基础知识 JS中使用typeof能得到哪些类型？ 答：undefined、number、boolean、string、object、function(补充：typeof可以分清值类型，引用类型不行只能判断函数。) 何时使用=== 何时使用==？ 1234if (obj.a == null) &#123; //这里相当于obj.a === null || obj.a === undefined,简写形式 //这是jquery源码中推荐的写法&#125; JS中有哪些内置函数(数据封装类对象) 答：Object、Array、Boolean、Number、String、Function、 Date、RegExp、Error JS变量按照存储方式区分为哪些类型，并描述其特点12345678910111213141516171819202122// 值类型var a = 10;var b = a;a = 11;console.log(b); //10// 引用类型var obj1 = &#123;x:100&#125;var obj2 = obj1;obj1.x = 200;console.log(obj2.x) //200//下面是自己做的练习 以后也要注意！var a = &#123; value: '1111'&#125;;var b = a;console.log(b); //&#123;value:'1111'&#125;console.log(a); //&#123;value:'1111'&#125;var a = &#123; value: 1111&#125;;console.log(b); //&#123;value:'1111'&#125; //这里b还是之前的对象，因为a重新赋予了一个对象指针，所以b的value没发生改变console.log(b === a); //false 值类型可以把数值分块存储在内存中，引用类型是好几个变量共用一个内存块，达到节省内存空间目的；值类型的值赋值之后不会相互干涉，引用类型赋值是变量指针的赋值，并不是真正值的拷贝，它们值的修改是相互干预的。 如何理解JSON JSON只不过是一个JS对象而已;一种数据格式 12JSON.stringify(&#123;a:10,b:20&#125;);JSON.parse('&#123;"a":10,"b":20&#125;'); 变量类型 值类型 vs 引用类型12345/* 值类型 */var a = 100;var b = a;a = 200;console.log(b); //100 123456/* 引用类型 （对象、数组、函数）*/var a = &#123;age:20&#125;var b = a;b.age = 21;console.log(a.age) //21//引用类型有个特点：可以扩展属性，自己做例子发现写函数，函数的name属性为函数名，name无法更改。 typeof运算符详解12345678typeof undefined //undefinedtypeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof &#123;&#125; //objecttypeof [] //objecttypeof null //objecttypeof console.log //function typeof只能区分出值类型的详细类型，引用类型区别不出来。 变量计算强制类型转换（值类型） 字符串拼接 ==运算符 if语句 逻辑运算 字符串拼接12var a = 100 + 10; //110var b = 100 + '10';//'10010' ==运算符123100 == '100' //true0 == '' //truenull == undefined //true if语句123456789101112var a = true;if (a) &#123; //...&#125;var b = 100;if (b) &#123; //...&#125;var c = '';if (c) &#123; //...&#125; 逻辑运算符123456console.log(10 &amp;&amp; 0); //0console.log('' || 'abc'); //'abc'console.log(!window.abc); //true//判断一个变量会被当做true还是falsevar a = 100;console.log(!!a); 原型和原型链 如何准确判断一个变量是数组类型 123var arr = [];console.log(arr instanceof Array);typeof arr //object,typeof是无法判断是否是数组的 写一个原型链继承的例子 123456789101112131415//动物function Animal() &#123; this.eat = function() &#123; console.log('animal eat'); &#125;;&#125;//狗function Dog() &#123; this.bark = function() &#123; console.log('dog bark'); &#125;;&#125;Dog.prototype = new Animal();//哈士奇var hashiqi = new Dog(); 123456789101112131415161718192021222324// 接下来代码演示时，会推荐更加贴近实战的原型继承实例function Elem(id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val) &#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; //链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;;Elem.prototype.on = function(type,fn) &#123; var elem = this.elem; elem.addEventListener(type,fn); return this;&#125;;var div1 = new Elem('div1');console.log(div1.html());div1.html('&lt;p&gt;hello world!&lt;/p&gt;');div1.on('click',function() &#123; alert('clicked');&#125;); 描述new一个对象的过程 12341.创建一个新对象2.this指向这个新对象3.执行代码，即对this赋值4.返回this zeptp(或其他框架)源码中如何使用原型链 阅读源码是高效提高技能的方式 但不能&quot;埋头苦钻&quot;有技巧在其中 慕课网搜索&quot;zepto设计和源码分析&quot; 知识点：构造函数12345678function Foo(name,age) &#123; this.name = name; this.age = age; this.class = 'class-1'; //return this //默认有这一行&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);//创建多个对象 构造函数 - 扩展- var a = {} 其实是 var a = new Object()的语法糖 - var a = [] 其实是 var a = new Array()的语法糖 - function Foo(){...} 其实是var Foo = new Function(...) - 使用instanceof判断一个函数是否是一个变量的构造函数 原型规则和示例 所有的引用类型(数组、对象、函数)，都具有对象特性，即可自由扩展属性(除了”null”意外) 12345678var obj = &#123;&#125;;obj.a = 100;console.log(obj); //&#123;a:100&#125;var arr = [];arr.a = 100;console.log(arr); //[a:100]function fn() &#123;&#125;fn.a = 100; 所有的引用类型(数组、对象、函数)，都有一个__proto__(隐式原型)属性，属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有的函数，都有一个prototype(显式原型)属性，属性值也是一个普通的对象 1console.log(fn.prototype); 所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值 1console.log(obj.__proto__ === Object.prototype); //true 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。 123456789101112131415//构造函数function Foo(name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function() &#123; alert(this.name);&#125;;//创建实例var f = new Foo('zhangsan');f.printName = function() &#123; console.log(this.name);&#125;;//测试f.printName();f.alertName(); this:指向调用者12345678//循环对象自身的属性for (var item in f) &#123; //高级浏览器已经在for in 中屏蔽了来自原型的属性 //但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; 原型链12345678910111213141516//构造函数function Foo(name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function() &#123; alert(this.name);&#125;;//创建实例var f = new Foo('zhangsan');f.printName = function() &#123; console.log(this.name);&#125;;//测试f.printName();f.alertName();f.toString(); //要去f.__proto__.__proto__中查找 instanceof用于判断引用类型属于哪个构造函数的方法 f instanceof Foo的判断逻辑是： f的__proto__一层一层往上，能否对应到Foo.prototype 再试着判断f instanceof Object 作用域和闭包函数声明和函数表达式12345678910111213//全局fn(); //函数声明提升function fn() &#123; //声明&#125;fn1(); //报错console.log(fn1); //undefined 变量提升var fn1 = function() &#123; //表达式&#125;;//var命令会发生变量提升console.log(a); //undefinedvar a = 2; 1234567891011121314151617181920212223fn('zhangsan'); //zhangsan 20function fn(name) &#123; age = 20; console.log(name,age); var age;&#125;fn1('zhangsan');//zhangsan 20//100function fn1(name) &#123; //函数 console.log(this); console.log(arguments); age = 20; console.log(name,age); var age; bar(100); function bar(num) &#123; console.log(num); &#125;&#125; 题目 说一下对变量提升的理解 变量定义 函数声明（注意和函数表达式的区别） 说明this几种不同的使用场景 作为构造函数执行 作为对象属性执行 作为普通函数执行 call apply bind 创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号 123456789101112131415161718192021222324//这是一个错误的写法！var i,a;for (i = 0;i &lt; 10;i++) &#123; a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click',function(e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a);&#125;//这是正确的写法var i;for (i = 0;i &lt; 10;i++) &#123; (function(i) &#123; var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click',function(e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a); &#125;)(i)&#125; 如何理解作用域 自由变量 作用域链，即自由变量的查找 闭包的两个场景 实际开发中闭包的应用1234567891011121314151617//闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad() &#123; var _list = []; return function(id) &#123; if (_list.indexOf(id) &gt;= 0) &#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;//使用var fristLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true 知识点 执行上下文 this 作用域 作用域链 闭包 执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 函数：变量定义、函数声明、this、arguments this this要在执行时才能确认值，定义时无法确认12345678910var a = &#123; name: 'A', fn: function() &#123; console.log(this.name); &#125;&#125;;a.fn(); //A this === aa.fn.call(&#123;name:'B'&#125;) //B this === &#123;name:'B'&#125;var fn1 = a.fn;fn1(); //this === window 场景 作为构造函数执行 1234function Foo(name) &#123; this.name = name;&#125;var f = new Foo('zhangsan'); 作为对象属性执行 1234567var obj = &#123; name: 'A', printName: function() &#123; console.log(this.name); &#125;&#125;;obj.printName(); 作为普通函数执行 1234function fn() &#123; console.log(this);&#125;fn(); //this === window call apply bind 12345function fn1(name,age) &#123; alert(name + "," + age); console.log(this);&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22); 12345var fn1 = function(name,age) &#123; alert(name + "," + age); console.log(this);&#125;.bind(&#123;x:100&#125;);fn1('zhangsan',22); 作用域 没有块级作用域 1234567891011if (true) &#123; var name = 'zhangsan';&#125;console.log(name);等同于var name;if (true) &#123; name = 'zhangsan';&#125;console.log(name);//尽量不要在块里声明变量，因为也是全局的，为了可读性，直接在外面声明它是一个全局变量，这样会易于理解。 只有函数和全局作用域 1234567var a = 100;function fn() &#123; var a = 200; console.log('fn',a);&#125;console.log('global',a);fn(); 作用域链12345678var a = 100;function fn() &#123; var b = 200; //当前作用域没有定义的变量，即"自由变量" console.log(a); console.log(b);&#125;fn(); 123456789101112var a = 100;function F1() &#123; var b = 200; function F2() &#123; var c = 300; console.log(a); //a是自由变量 console.log(b); //b是自由变量 console.log(c); &#125; F2();&#125;F1(); 闭包1234567891011function F1() &#123; var a = 100; //返回一个函数（函数作为返回值） return function() &#123; console.log(a); &#125;&#125;//f1得到一个函数var f1 = F1();var a = 200;f1(); 闭包的使用场景 函数作为返回值（上一个demo） 函数作为参数传递（自己思考）123456789101112function F1() &#123; var a = 100; return function() &#123; console.log(a); //自由变量，父作用域寻找 &#125;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn();&#125;F2(f1); 异步和单线程题目 同步和异步的区别是什么？分别举一个同步和异步的例子 同步会阻塞代码执行，而异步不会 alert是同步，setTimeout是异步 一个关于setTimeout的笔试题 123456789console.log(1);setTimeout(function() &#123; console.log(2);&#125;,0);console.log(3);setTimeout(function() &#123; console.log(4);&#125;,1000);console.log(5); 前端使用异步的场景有哪些 定时任务：setTimeout,setInterval 网络请求：ajax请求，动态加载 事件绑定知识点 什么是异步（对比同步） 123456789console.log(100);setTimeout(function() &#123; console.log(200);&#125;,1000);console.log(300);//对比同步console.log(100);alert(200);console.log(300); 何时需要异步 在可能发生的等待的情况 等待过程中不能像alert一样阻塞程序运行 因此，所有的’’等待的情况”都需要异步 前端使用异步的场景 定时任务：setTimeout,setInterval 网络请求：ajax请求，动态加载 事件绑定1234567891011121314151617181920//ajax请求代码示例console.log('start');$.get('./data1.json',function(data1) &#123; console.log(data1);&#125;);console.log('end');//&lt;img&gt;加载示例console.log('start');var img = document.createElement('img');img.onload = function() &#123; console.log('loaded');&#125;img.src = '/xxx.png';console.log('end');//事件绑定示例console.log('start');document.getElementById('btn1').addEventListener('click',function() &#123; alert('clicked');&#125;);console.log('end'); 异步和单线程 12345678910console.log(100);setTimeout(function() &#123; console.log(200);&#125;);console.log(300);//执行第一行，打印100//执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）//执行最后一行，打印300//待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的要执行//发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行 其他知识题目 获取2017-06-10格式的日期 123456789101112131415161718192021function formatDate(dt) &#123; if (!dt) &#123; dt = new Date(); &#125; var year = dt.getFullYear(); var month = dt.getMonth() + 1; var date = dt.getDate(); if (month &lt; 10) &#123; //强制类型转换 month = '0' + month; &#125; if (date &lt; 10) &#123; //强制类型转换 date = '0' + date; &#125; //强制类型转换 return year + '-' + month + '-' + date;&#125;var dt = new Date();var formatDate = formatDate(dt);console.log(formatDate); 获取随机数，要求是长度一致的字符串格式 1234var random = Math.random();random = random + '0000000000'; //后面加上10个零random = random.slice(0,10);console.log(random); 写一个能遍历对象和数组的通用forEach函数 1234567891011121314151617181920212223function forEach(obj,fn) &#123; var key; if (obj instanceof Array) &#123; //准确判断是不是数组 obj.forEach(function(item,index) &#123; fn(index,item); &#125;); &#125; else &#123; // 不是数组就是对象 for (key in obj) &#123; fn(key,obj[key]); &#125; &#125;&#125;var arr = [1,2,3];//注意，这里参数的顺序换了，为了和对象的遍历格式一致forEach(arr,function(index,item) &#123; console.log(index,item); &#125;);var obj = &#123;x:100,y:200&#125;;forEach(obj,function(key,value) &#123; console.log(key,value);&#125;); 知识点： 日期 Math 数组API 对象API日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date();dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月 （0 - 11）dt.getDate(); //日 （0 - 31）dt.getHours(); //小时 （0 - 23）dt.getMinutes(); //分钟 （0 - 59）dt.getSeconds(); //秒 （0 - 59） Math 获取随机数 Math.random()数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否有至少一个元素符合条件 sort 排序 map 对元素重新组装，生成新数组 filter 过滤符合条件的元素123456//forEachvar arr = [1,2,3];arr.forEach(function(item,index) &#123; //遍历数组的所有元素 console.log(index,item);&#125;); 123456789//everyvar arr = [1,2,3];var result = arr.every(function(item,index) &#123; //用来判断所有的数组元素，都满足一个条件 if (item &lt; 4) &#123; return true; &#125;&#125;);console.log(result); 123456789//somevar arr = [1,2,3];var result = arr.some(function(item,index) &#123; //用来判断所有的数组元素，只要有一个满足条件即可 if (item &lt; 2) &#123; return true; &#125;&#125;);console.log(result); 123456789//sortvar arr = [1,4,2,3,5,10,16,25];var arr2 = arr.sort(function(a,b) &#123; //从小到大排序 return a - b; //从大到小排序 //return b - a;&#125;);console.log(arr2); 1234567//mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index) &#123; //将元素重新组装，并返回 return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;);console.log(arr2); 123456789//filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index) &#123; //通过某一条件过滤数组 if (item &gt;= 2) &#123; return true; &#125;&#125;);console.log(arr2); 对象API123456789101112var obj = &#123; x: 100, y: 200, z: 300&#125;;var key;for (key in obj) &#123; //注意这里的hasOwnProperty,再讲原型链时候讲过了,判断该属性是对象自身的属性，以防是来源于__proto__的 if (obj.hasOwnProperty(key)) &#123; console.log(key,obj[key]); &#125;&#125; 回顾JS基础知识 变量类型和计算 原型和原型链 闭包和作用域 异步和单线程 其他（如日期、Math、各种常用API） 特点：表面看来并不能用于工作中开发代码 内置函数：Object Array Boolean String … 内置对象：Math JSON … 我们连在网页弹出一句hello world都不能实现 JS基础知识：ECMA 262标准 JS-Web-API：W3C标准 W3C标准中关于JS的规定有： DOM操作 BOM操作 事件绑定 ajax请求(包括http协议) 存储 页面弹框是window.alert(123),浏览器需要做： 定义一个window全局变量，对象类型 给它定义一个alert属性，属性值是一个函数 获取元素document.getElementById(id),浏览器需要： 定义一个document全局变量，对象类型 给它定义一个getElementById的属性，属性值是一个函数 但是W3C标准没有规定任何JS基础相关的东西 不管什么变量类型、原型、作用域和异步 只管定义用于浏览器中JS操作页面的API和全局变量 全面考虑，JS内置的全局函数和对象有哪些? 之前讲过的Object Array Boolean String Math JSON等 刚刚提到的 window document 接下来还要继续讲到的所有未定义的全局变量，如navigator.userAgent 常说的JS（浏览器执行的JS）包含两个部分： JS基础知识（ECMA262标准） JS-Web-API（W3C标准） JS-Web-APIDOM操作题目 DOM是哪种基本的数据结构？ 树 DOM操作的常用API有哪些？ 获取DOM节点，以及节点的property和Attribute 获取父节点，获取子节点 新增节点，删除节点 DOM节点的attr和property有何区别 property只是一个JS对象的属性的修改 Attribute是对html标签属性的修改知识点 DOM本质 DOM节点操作 浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型而已。 DOM结构操作 DOM节点操作 获取DOM节点 123456var div1 = document.getElementById('div1'); //元素var divList = document.getElementsByTagName('div'); //集合console.log(divList.length);console.log(divList[0]);var containerList = document.getElementsByClassName('.container'); //集合var pList = document.querySelectorAll('p'); //集合 property 123456789var pList = document.querySelectorAll('p');var p = pList[0];console.log(p.style.width); //获取样式p.style.width = '100px'; //修改样式console.log(p.className); //获取classp.className = 'p1'; //修改class// 获取nodeName 和 nodeTypeconsole.log(p.nodeName);console.log(p.nodeType); Attribute 123456var pList = document.querySelectorAll('p');var p = pList[0];p.getAttribute('data-name');p.setAttribute('data-name','imooc');p.getAttribute('style');p.setAttribute('style','font-size:30px;'); DOM结构操作 新增节点 12345678var div1 = document.getElementById('div1');//添加新节点var p1 = document.createElement('p');p1.innerHTML = 'this is p1';div1.appendChild(p1); //添加新创建的元素//移动已有节点var p2 = document.getElementById('p2');div1.appendChild(p2); 获取父节点 12var div1 = document.getElementById('div1');var parent = div1.parentElement; 获取子节点 1var child = div1.childNodes; 删除节点 1div1.removeChild(child[0]); BOM操作题目 如何检测浏览器类型 123var ua = navigator.userAgent;var isChrome = ua.indexOf('Chrome');console.log(isChrome); 拆解url的各部分 123456// locationconsole.log(location.href);console.log(location.protocol); // 'http:' 'https:'console.log(location.pathname); // '/learn/199'console.log(location.search);console.log(location.hash); 知识点 navigator 1234//navigatorvar ua = navigator.userAgent;var isChrome = ua.indexOf('Chrome');console.log(isChrome); screen 123//screenconsole.log(screen.width);console.log(screen.height); location 123456// locationconsole.log(location.href);console.log(location.protocol); // 'http:' 'https:'console.log(location.pathname); // '/learn/199'console.log(location.search);console.log(location.hash); history 12history.back();history.forward(); 事件题目 编写一个通用的事件监听函数 1234567891011121314151617function bindEvent(elem,type,selector,fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type,function(e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target,e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125; 描述事件冒泡流程 DOM树形结构 事件冒泡 阻止冒泡 冒泡的应用 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 使用代理 知道代理的两个优点 知识点 通用事件绑定 123456789101112var btn = document.getElementById('btn1');btn.addEventListener('click',function(event) &#123; console.log('clicked');&#125;);function bindEvent(elem,type,fn) &#123; elem.addEventListener(type,fn);&#125;var a = document.getElementById('link1');bindEvent(a,'click',function(e) &#123; e.preventDefault(); //阻止默认行为 alert('clicked');&#125;); 事件冒泡 123456789101112131415161718192021222324252627//html部分&lt;body&gt; &lt;div class='div1'&gt; &lt;p id='p1'&gt;激活&lt;/p&gt; &lt;p id='p2'&gt;取消&lt;/p&gt; &lt;p id='p3'&gt;取消&lt;/p&gt; &lt;p id='p4'&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id='div2'&gt; &lt;p id='p5'&gt;取消&lt;/p&gt; &lt;p id='p5'&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;//js部分var p1 = document.getElementById('p1');var div1 = document.getElementsByClassName('div1')[0];var div2 = document.getElementById('div2');bindEvent(p1,'click',function(e) &#123; e.stopPropagation(); alert('激活');&#125;);bindEvent(div1,'click',function(e) &#123; alert('取消'); &#125;);bindEvent(div2,'click',function(e) &#123; alert('取消'); &#125;); 代理 12345678910111213141516//html代码&lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;!--会随时新增更多a标签--&gt;&lt;/div&gt;//js部分var div1 = document.getElementById('div1');div1.addEventListener('click',function(e) &#123; var target = e.target; if (target.nodeName === 'A') &#123; alert(target.innerHTML); &#125;&#125;); 完善通用绑定事件的函数123456789101112131415161718192021222324252627function bindEvent(elem,type,selector,fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type,function(e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target,e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125;//使用代理var div1 = document.getElementById('div1');bindEvent(div1,'click','a',function(e) &#123; console.log(this.innerHTML);&#125;);//不使用代理var a = document.getElementById('a1');bindEvent(a,'click',function(e) &#123; console.log(a.innerHTML);&#125;); 代理的好处 代码简洁 减少浏览器内存占用 Ajax题目 手动编写一个ajax，不依赖第三方库 12345678910var xhr = new XMLHttpRequest();xhr.open("GET","/api",false);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;&#125;;xhr.send(null); 跨域的几种实现方式JSONP服务器端设置http header知识点 XMLHttpRequest 状态码说明 跨域readyState 0 -(未初始化)还没有调用send()方法 1 -(载入)已调用send()方法，正在发送请求 2 -(载入完成)send()方法执行完成，已经接收到全部响应内容 3 -(交互)正在解析响应内容 4 -(完成)响应内容解析完成，可以在客户端调用了status 2xx - 表示成功处理请求。如200 3xx - 需要重定向，浏览器直接跳转 4xx - 客户端请求错误，如404 5xx - 服务器端错误 跨域 什么是跨域浏览器有同源策略，不允许ajax访问其他域接口跨域条件：协议、域名、端口，有一个不同就算跨域 JSONP 服务器端设置http header可以跨域的三个标签 但是有三个标签允许跨域加载资源 &lt;img src=xxx&gt; &lt;link href=xxxx&gt; &lt;script src=xxx&gt;&lt;/script&gt;三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN,CDN也可以是其他域 &lt;script&gt;可以用于JSONP跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许即可获取，那是浏览器同源策略出现漏洞JSONP实现原理 加载http://coding.m.imooc.com/classindex.html 不一定服务器端真正有一个classindex.html文件 服务端可以根据请求，动态生成一个文件，返回 同理于&lt;script src=&quot;http://coding.m.imooc.com/api.js&quot;&gt;&lt;/script&gt; 例如你的网站要跨域访问慕课网的一个接口 慕课给你一个地址http://coding.m.imooc.com/api.js 返回内容格式如callback({x:100,y:200})(可动态生成)12345678&lt;script&gt;window.callback = function(data) &#123; //这是我们跨域得到信息 console.log(data);&#125;;&lt;/script&gt;&lt;script src="http://coding.m.imooc.com/api.js"&gt;&lt;/script&gt;&lt;!--以上返回callback(&#123;x:100,y:200&#125;) --&gt; 服务器端设置http header 另外一个解决跨域的简洁方法，需要服务器端来做 但是作为交互方，我们必须知道这个方法 是将来解决跨域问题的一个趋势1234567//注意：不同后端语言的写法可能不一样//第二个参数填写允许跨域的域名称，不建议直接写"*"response.setHeader("Access-Control-Allow-Origin","http://a.com,http://b.com");response.setHeader("Access-Control-Allow-Header","X-Requested-With");response.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");//接收跨域的cookieresponse.setHeader("Access-Control-Allow-Credentials","true"); 存储题目 请描述cookie，sessionStorage和localStorage的区别？ 容量 是否会携带到ajax中 API易用性 知识点 本身用于客户端和服务器端通信 但是它有本地存储的功能，于是就被”借用” 使用document.cookie = …获取和修改即可 cookie用于存储的缺点 存储量太小，只有4KB 所有的http请求都带着，会影响获取资源的效率 API简单，需要封装才能用document.cookie = … locationStorage和sessionStorage HTML5专门为存储而设计，最大容量5M API简单易用 localStorage.setItem(key,value); localStorage.getItem(key); 坑： iOS safari隐藏模式下 localStorage.getItem会报错 建议统一使用try-catch封装 开发环境 面试官想通过开发环境了解面试者的经验 开发环境，最能体现工作产出的效率 会以聊天的形式为主，而不是出具体的问题 关于开发环境 IDE(写代码的效率) git(代码版本管理，多人协作开发) JS模块化 打包工具 上线回滚的流程 IDE webstorm sublime vscode atom 插件 Git 正式项目都需要代码版本管理 大型项目需要多人协作开发 Git和linux是一个作者 网络Git服务器如coding.net github.com 一般公司代码非开源，都有自己的Git服务器 搭建Git服务器无需你了解太多 Git的基本操作必须要熟练 常用Git命令 git add . (.把所有项目上传，也可以加文件名) git checkout xxx （改错了，想还原回去） git commit -m “xxx” （git commit把项目弄到本地 -m 加备注） git push origin master （提交给远程仓库） git pull orgin master （别人把你提交的pull下来） git branch （多人协作 切换到当前分支） git checked -b xxx/git checkout xxx （git checked -b新建分支/git checkout 切换到已有分支） git merge xxx 模块化 不使用模块化的情况 使用模块化 AMD CommonJS 不使用模块化 util.js getFormatDate函数 a-util.js aGetFormatDate函数 使用getFormatDate a.js aGetFormatDate1234567891011121314//util.jsfunction getFormatDate(data,type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 格式 // ...&#125;//a-util.jsfunction aGetFormatDate(date) &#123; //要求返回 2017年6月15日 格式 return getFormatDate(date,2);&#125;//a.jsvar dt = new Date();console.log(aGetFormatDate(dt)); 12345&lt;script src="util.js"&gt;&lt;/script&gt;&lt;script src="a-util.js"&gt;&lt;/script&gt;&lt;script src="a.js"&gt;&lt;/script&gt;&lt;!-- 1.这些代码中的函数必须是全局变量，才能暴露给使用方。全局变量污染 --&gt;&lt;!-- 2.a.js知道要引用a-util.js,但是他知道还需要依赖于util.js吗？ --&gt; AMD require.js 全局define函数 全局require函数 依赖JS会自动、异步加载 使用require.js12345678910111213141516171819202122232425262728293031323334//util.jsdefine(function() &#123; return &#123; getFormatDate: function(data,type) &#123; if (type === 1) &#123; return '2017-06-15'; &#125; if (type === 2) &#123; return '2017年6月15日'; &#125; &#125; &#125;&#125;)；//a-util.jsdefine(['./util.js'],function(util) &#123; return &#123; aGetFormatDate: function(date) &#123; return util.getFormatDate(date,2); &#125; &#125;&#125;);//a.jsdefine(['./a-util.js'],function() &#123; return &#123; printDate: function(date) &#123; console.log(aUtil.aGetFormatDate(date)); &#125; &#125;&#125;);//main.jsrequire(['./a.js'],function(a) &#123; var date = new Date(); a.printDate(date);&#125;); CommonJS nodejs模块化规范，现在被大量用前端，原因： 前端开发依赖的插件和库，都可以从npm中获取 构建工具的高度自动化，使得使用npm的成本非常低 CommonJS不会异步加载JS，而是同步一次性记载出来123456789101112131415161718//util.jsmodule.exports = &#123; getFormatDate: function(data,type) &#123; if (type === 1) &#123; return '2017-06-15'; &#125; if (type === 2) &#123; return '2017年6月15日'； &#125; &#125;&#125;;//a-util.jsvar util = require('util.js');module.exports = &#123; aGetFormatDate: function() &#123; return util.getFormatDate(date,2); &#125;&#125; AMD和CommonJS的使用场景 需要异步加载JS，使用AMD 使用了npm之后建议使用CommonJS 上线和回滚知识点： 上线和回滚的基本流程 linux基本命令 上线回滚流程介绍 是非常重要的开发环节 各个公司的具体流程不同 由专门的工具后者系统完成，我们无需关心细节 如果你没有参与过，面试时也要说出要点 只讲要点，具体实现无法讲解 上线流程要点 将测试完成的代码提交到git版本库的master分支 将当前服务器的代码全部打包并记录版本号，备份 将master分支的代码提交覆盖到线上服务器，生成新版本号 回滚流程要点 将当前服务器的代码打包并记录版本号，备份 将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号 linux基本命令 服务器使用linux居多，server版，只有命令行 测试环境要匹配线上环境，因此也是linux 经常需要登录测试机来自己配置、获取数据 运行环境 浏览器就可以通过访问链接来得到页面的内容 通过绘制和渲染，显示出页面的最终的样子 整个过程中，我们需要考虑什么问题？ 知识点 页面加载过程 性能优化 安全性 页面加载题目 从输入url到得到html的详细过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求 浏览器得到返回内容 window.onload 和 DOMContentLoaded的区别 页面的全部资源加载完才会执行，包括图片、视频等 DOM渲染完即可执行，此时图片、视频还没有加载完 知识点 加载资源的形式 加载一个资源的过程 浏览器渲染页面的过程 加载资源的形式 输入url（或跳转页面）加载html 加载html中的静态资源 &lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt; 加载一个资源的过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求 浏览器得到返回内容 浏览器渲染页面的过程 根据HTML结构生成DOM Tree 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 window.onload和DOMContentLoaded123456window.addEventListener('load',function() &#123; //页面的全部资源加载完才会执行，包括图片、视频等&#125;);document.addEventListener('DOMContentLoaded',function() &#123; //DOM渲染完即可执行，此时图片、视频还可能没有加载完&#125;); 性能优化原则 多使用内存、缓存或者其他方法 减少CPU计算、较少网络 从哪里入手 加载页面和静态资源 页面渲染 加载资源优化 静态资源的压缩合并 静态资源缓存 使用CDN让资源加载更快 使用SSR后端渲染，数据直接输出到HTML中 渲染优化 CSS放前面，JS放后面 懒加载（图片懒加载、下拉加载更多） 减少DOM查询，对DOM查询做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作（如DOMContentLoaded） 缓存 通过了解名称控制缓存 &lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt; 只有内容改变的时候，链接名称才会改变 &lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt; 使用SSR后端渲染 现在Vue React提出了这样的概念 其实jsp php asp都属于后端渲染 懒加载12345&lt;img src="img1" src="preview.png" data-realsrc="abc.png"/&gt;&lt;script type="text/javascript"&gt; var img1 = document.getElementById('img1'); img1.src = img1.getAttribute('data-realsrc');&lt;/script&gt; 缓存DOM查询1234567891011//未缓存DOM查询var i;for (i = 0;i &lt; document.getElementsByTagName('p').length;i++) &#123; //todo&#125;//缓存了DOM查询var pList = document.getElementsByTagName('p');var i;for (i = 0;i &lt; pList.length;i++) &#123; //todo&#125; 合并DOM插入12345678910var listNode = document.getElementById('list');//要插入10个li标签var frag = document.createDocumentFragment();var x,li;for (x = 0;x &lt; 10;x++) &#123; li = document.createElement("li"); li.innerHTML = "List item " + x; frag.appendChild(li);&#125;listNode.appendChild(frag); 事件节流12345678910var textarea = document.getElementById('text');var timeoutId;textarea.addEventListener('keyup',function() &#123; if (timeoutId) &#123; clearTimeout(timeoutId); &#125; timeoutId = setTimeout(function() &#123; //触发change事件 &#125;,100);&#125;); 安全性 XSS跨站请求攻击 XSRF跨站请求伪造 XSS 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取cookie，发送自己的服务器 发布博客，有人查看博客内容 会把查看者的cookie发送到攻击者的服务器 如何预防 前端替换关键字，例如替换&lt;为&amp;lt;&gt;为&amp;gt; 后端替换 XSRF 你已登录一个购物网站，正在浏览商品 该网站付费接口是xxx.com/pay?id=100但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx.com/pay?id=100&gt; 你查看邮件的时候，就已经悄悄的付费购买了 解决方案 增加验证流程，如输入指纹、密码、短信验证码 技巧 简历 面试过程中… 简历 简洁明了，重点突出项目经历和解决方案 把个人博客放在简历中，并且定期维护更新博客 把个人的开源项目放在简历中，并维护开源项目 简历千万不要造假，要保持能力和经历上的真实性 面试过程中 如何看待加班？加班就像借钱，救急不救穷 千万不可挑战面试官，不要反考面试官 学会给面试官惊喜，但不要太多 遇到不会回答的问题，说出你知道的也可以 谈谈你的缺点—说一下你最近正在学什么就可以了]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2018%2F02%2F16%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[勿忘初心。 相关知识点：ES6:笔记：ES6学习笔记资料：阮一峰ES6 node.js:官网下载安装。检查安装成功的命令： node -v(node版本查询) npm -v(npm版本查询)cnpm:淘宝镜像 webpack:待补充： window命令：cd 定位到目录，用法：cd + 路径dir 列出文件列表cls 清空命令提示符窗口内容cd.. 定位至上层目录待补充。 React:React基础知识、React：用于构建用户界面的 JavaScript 库特点： 声明式：React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。（以声明式编写UI，可以让你的代码更加可靠，且方便调试。） 组件化：创建好拥有各自状态的组件，再由组件构成更加复杂的界面。（无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。） React组件基础、一：初步配置React开发环境 npm项目初始化：npm init(创建一个初始化的package.json) 项目依赖包安装: react、react-dom、babelify、babel-preset-react、babel-preset-es2015 （babel-core、babel-loader、webpack、webpack-dev-server） eg：npm react –save 保存到生产依赖环境npm react --save --dev 保存到开发依赖环境 webpack 热加载配置 全局安装webpack webpack-dev-server 项目内安装webpack webpack-dev-server 实现打包 webpack –watch 监控项目热加载浏览器：localhost:8080/webpack-dev-server/index.html 二：虚拟DOM概念如何理解虚拟DOM? 组件 组件的return 函数里返回的HTML节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{}入口的定义： ReactDOM.render(,document.getElementById(‘’)); 三：React多组件嵌套 组件也可以通过参数的形式传递 组件的return函数里返回的HTML节点必须是一个 注意项目命名的规范与文件的结构化 补充：代码中的’./‘ 表示当前目录下;.gitignore文件名写错以至于将相关包上传，以后注意！ 四：JSX内置表达式 {window.username == ‘’ ? ‘默认用户名’ : ‘用户名:’ + username} input中disable={} 单引号去掉 {/注释/} HTML要显示可以进行Unicode转码。 eg:&nbsp; HTML要显示还可以通过&lt;div dangerouslySetinnerHTML={ {__html:html} }&gt;&lt;/div&gt; 注意此方法可能会存在XSS攻击 补充：.gitignore内容写错node_module，应该是node_modules注意注意！加s 五：生命周期生命周期中的函数类似于钩子：钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。 component instantiated （组件初始化） getDefaultProps (获取默认属性） getInitialState (获取初始化state) componenntWillMount (组件将要加载的函数）componentDidMount (组件加载完毕的函数) propschanged （属性的更改） componentWillUpdate (将要update) componentDidUpdate (update完成) componentdeleted （组件删除） componentWillUnmount （组件卸载的函数） 补充:出现的问题引入的包 ‘react’、’react-dom’注意小写，创建组件 extends React.Component 写对，未解决问题：React Developer Tools会自动检测React组件，不过在webpack-dev-server模式下，webpack会自动将React组件放入到iframe下，导致React组件检测失败，变通方法是webpack-dev-server配置在–inline模式下即可，但是未成功，解决方法：在webpack-dev-server配置中没有inline:true去开启inline模式，因为webpack-dev-server模块无法访问webpack的配置。因此，用户必须添加webpack-dev-server的客户端入口文件到webpack的配置中，webpack-dev-server简单使用 React属性与事件、一：State 属性 state对于模块属于 自身 属性 初始化：this.state = {username:”Parry”}; 初始化可以放置在构造函数constructor里 修改state:this.setState({username:’liuxilei’}); state的作用域只属于当前的类，不污染其他模块 补充：状态值会立即（自动）反映在虚拟dom上然后显示在dom上;ReactDOM.render(,document.getElementById(‘’));这里没有引号，state改变可以实时反应在页面上，不刷新 二：Props属性 props 对于模块属于 外来 属性 传递参数：&lt;BodyIndex username=&#39;liuxilei&#39;/&gt; 模块中接收参数：this.props.username 三：事件与数据的双向绑定事件的绑定：注意es6的语法 可以在构造函数里绑定this:this.forceUpdateHandler = this.forceUpdateHandler.bind(this);.或者调用时绑定：onClick = {this.changeUserInfo.bind(this,50)}子页面向父页面传递参数的方法 在子页面中通过调用父页面传递过来的事件props进行组件间的参数传递 好好理解这里的onChange事件，为什么不用onBlur补充：this的指向：类的方法内部如果含有this，它将默认指向类的实例。MDN 四：可复用组件，真正让React开发快速、高效的地方Prop验证 https://doc.react-china.org/docs/typechecking-with-proptypes.html 注意: React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替。！！！！默认Prop值 const defaultProps = {text:’Hello world’}; 使用方法：BodyIndex.defaultProps = defaultProps;传递所有参数的快捷方式 &lt;Component{...this.props} more={&#39;values&#39;}/&gt; 五：组件的Refs操作DOM的两种方法 原始获取方法：var myDiv = document.getElementById(&#39;myDiv&#39;);React.findDOMNode(myDiv).style.color = &#39;red&#39;; （推荐使用）方法二的定义：&lt;input ref=&#39;myInput&#39; /&gt; 方法二的获取：this.refs.myInput Refs是访问到组件内部DOM节点唯一可靠的方法 Refs会自动销毁对子组件的引用 不要在render或render之前对Refs进行调用 不要滥用Refs 六：独立组件间共享Mixins 不同的组件之间共用功能、共享代码 和页面具有类似的生命周期 ES6下的使用要安装react-mixins]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习总结]]></title>
    <url>%2F2018%2F02%2F15%2FES6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[勿忘初心。 ES6学习总结第一部分：let、const命令作用域部分：在es6之前，es5有两个作用域:全局作用域和函数作用域1234567function test() &#123; for (var i = 1;i &lt; 3;i++) &#123; console.log(i); &#125; console.log(i);&#125;test(); //输出结果1 2 3 1234567function test() &#123; for (let i = 1;i &lt; 3;i++) &#123; console.log(i); &#125; console.log(i);&#125;test(); //报错:ReferenceError: i is not defined es6的块级作用域 es6中一段代码是用{}包起来的，这个大括号里面就是一个块级作用域，在这个作用域里面声明的变量在这个外面就不存在了，可以理解成这个变量的生命周期结束了;es6中强制开启了严格模式, es5中”use strict”;来开启严格模式。 let、const部分：let 声明变量不能再次声明12345function test() &#123; let a = 1; let a = 2;&#125;test();//报错:Error:Duplicate declaration(重复声明) const声明的常量是不能修改的123456function test() &#123; const PI = 3.1415926; PI = 8; console.log(PI);&#125;test();//报错：&quot;PI&quot; is read-only(PI是一个只读属性) const声明时必须赋值12345function test() &#123; const PI; PI = 3.1415926;&#125;//报错:Error:Unexpected token(代码不完整) 补充：const声明的常量是不能修改的，这句话不严谨解释：123456789function test() &#123; const PI = 3.1415926; const k = &#123; a: 1 &#125; k.b = 3; console.log(PI,k);&#125;test(); const声明的k对象是引用类型，返回值是对象存储内存中的指针，声明的k是指向对象中存储的指针 ，这个指针是不变的，但是对象本身是可变的。 第二部分：解构赋值什么是解构赋值：本质就是一种赋值，赋值操作符左边一种结构，右边一种结构，然后一一对应。解构赋值的分类 数组解构赋值 对象解构赋值 字符串解构赋值 布尔值解构赋值 函数参数解构赋值 数值解构赋值 数组解构赋值（左右都是数组）、对象解构赋值（左右都是对象）、字符串解构赋值（左边是数组，右边是字符串）、布尔值解构赋值（对象解构赋值中的一种）、函数参数解构赋值（数组解构赋值在函数参数这里的应用）、数值解构赋值（对象解构赋值中的一种） 1234//数组解构赋值（常见）let a,b,rest;[a,b] = [1,2];console.log(a,b);//1，2 123let a,b,rest;[a,b,...rest] = [1,2,3,4,5,6];console.log(a,b,rest); //1，2，[3,4,5,6] 1234//对象解构赋值（常见）let a,b;(&#123;a,b&#125; = &#123;a: 1,b: 2&#125;) //注意这里的括号console.log(a,b); //1，2 数组解构赋值、对象解构赋值使用的基本方法、默认值和应用场景 1234//默认值let a,b,c,rest;[a,b,c = 3] = [1,2];console.log(a,b,c); //1，2，3 123let a,b,c,rest;[a,b,c] = [1,2];console.log(a,b,c);//1，2，undefined (默认值的设定就是为了放置这种情况) 数组解构赋值的应用场景12345//变量的交换let a = 1;let b = 2;[a,b] = [b,a];console.log(a,b); //2，1 1234567//接收函数返回值 function f() &#123; return [1,2];&#125;let a,b;[a,b] = f();console.log(a,b); //1，2 123456function f() &#123; return [1,2,3,4,5];&#125;let a,b;[a,,,b] = f();console.log(a,b); //1，4 123456function f() &#123; return [1,2,3,4,5];&#125;let a,b;[a,,...b] = f();console.log(a,b); /1，[3,4,5] 1234567//对象解构赋值基本使用方法let o = &#123;p: 42,q: true&#125;let &#123;p,q&#125; = o;console.log(p,q); //42，true//默认值let &#123;a = 10,b = 5&#125; = &#123;a: 3&#125;;console.log(a,b); //3，5 对象解构赋值应用场景12345678910//模拟服务端给前端的JSON对象 let metaData = &#123; &apos;title&apos;: &apos;abc&apos;, &apos;test&apos; : [&#123; title: &apos;test&apos;, desc: &apos;description&apos; &#125;]&#125;let &#123;title: esTitle,test: [&#123;title: cnTitle&#125;]&#125; = metaData;console.log(esTitle,cnTitle); 第三部分：正则扩展正则新增特性 构造函数的变化 正则方法的扩展 u修饰符 y修饰符 s修饰符 构造函数的变化 1234567//es5创建正则的方式let regex = new RegExp(&apos;xyz&apos;,&apos;i&apos;);let regex2 = new RegExp(/xyz/i);console.log(regex.test(&apos;xyz123&apos;),regex2.test(&apos;xyz123&apos;));//true true//es6扩展的方式let regex3 = new RegExp(&apos;/xyz/ig&apos;,&apos;i&apos;); console.log(regex3.flags); //i y修饰符12345678//y也是全局搜索let s = &apos;bbb_bb_b&apos;;let a1 = /b+/g;let a2 = /b+/y;console.log(&apos;one&apos;,a1.exec(s),a2.exec(s)); //one [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;] [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;]console.log(&apos;two&apos;,a1.exec(s),a2.exec(s)); //two [&quot;bb&quot;, index: 4, input: &quot;bbb_bb_b&quot;] null//sticky判断是否带y修饰符console.log(a1.sticky,a2.sticky); //false true u修饰符1234567console.log(&apos;u-1&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); //u-1 trueconsole.log(&apos;u-2&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); //u-2 falseconsole.log(/\u&#123;61&#125;/.test(&apos;a&apos;));console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;));console.log(`\u&#123;20BB7&#125;`); //待补充… 第四部分：字符串扩展字符串新增特性 Unicode表示法 遍历接口 模板字符串 新增方法（10种） Unicode表示方法1234console.log(&apos;a&apos;,`\u0061`); //a aconsole.log(&apos;s&apos;,`\u20BB7`); //乱码console.log(&apos;s&apos;,`\u&#123;20BB7&#125;`); 12345678910111213let s = &apos;?&apos;; console.log(&apos;length&apos;,s.length);console.log(&apos;0&apos;,s.charAt(0));console.log(&apos;1&apos;,s.charAt(1));console.log(&apos;at0&apos;,s.charCodeAt(0));console.log(&apos;at1&apos;,s.charCodeAt(1));let s1 = &apos;?a&apos;;console.log(&apos;length&apos;,s1.length);console.log(&apos;code0&apos;,s1.codePointAt(0));console.log(&apos;code0&apos;,s1.codePointAt(0).toString(16));console.log(&apos;code1&apos;,s1.codePointAt(1));console.log(&apos;code2&apos;,s1.codePointAt(2)); 123//理解怎么用就okconsole.log(String.fromCharCode(&apos;0x20bb7&apos;));console.log(String.fromCodePoint(&apos;0x20bb7&apos;)); 字符串遍历器接口12345678910111213141516let str = &apos;\u&#123;20bb7&#125;abc&apos;;for (let i = 0;i &lt; str.length;i++) &#123; console.log(&apos;es5&apos;,str[i]);&#125;//es5 乱码//es5 乱码//es5 a//es5 b//es5 cfor (let code of str) &#123; console.log(&apos;es6&apos;,code);&#125;//es6 吉//es6 a//es6 b//es6 c 12345//判断字符串是否包含某个字符串，或者以某个字符串开始或结束的let str = &apos;string&apos;;console.log(&apos;includes&apos;,str.includes(&apos;c&apos;)); //includes falseconsole.log(&apos;start&apos;,str.startsWith(&apos;str&apos;)); //start trueconsole.log(&apos;end&apos;,str.endsWith(&apos;ng&apos;)); //end true 123//把某个字符串重复两遍let str = &apos;abc&apos;;console.log(str.repeat(2)); //abcabc 模板字符串（很重要）1234let name = &apos;list&apos;;let info = &apos;hello world&apos;;let m = `i am $&#123;name&#125;,$&#123;info&#125;`; console.log(m); //i am list,hello world 1234//es7草案//补白console.log(&apos;1&apos;.padStart(2,&apos;0&apos;)); //01console.log(&apos;1&apos;.padEnd(2,&apos;0&apos;)); //10 1234567891011//标签模板(很重要)//作用：过滤html字符串，防止xss攻击;处理多语言转换，通过不同的return返回不同的语言let user = &#123; name: &apos;list&apos;, info: &apos;hello world&apos;&#125;;console.log(abc`i am $&#123;user.name&#125;,$&#123;user.info&#125;`); function abc(s,v1,v2) &#123; console.log(s,v1,v2); return s + v1 + v2;&#125; 12345//用的不多，了解即可 rawconsole.log(String.raw`Hi\n$&#123;1+2&#125;`); //Hi\n3console.log(`Hi\n$&#123;1+2&#125;`);\\Hi\\3 第五部分：数值扩展数值处理新增特性 新增方法 方法调整 12console.log(0b111110111); //503 (二进制)console.log(0o767); //503 (八进制) 12345//使用频率不高，了解即可console.log(&apos;15&apos;,Number.isFinite(15)); //15 trueconsole.log(&apos;NaN&apos;,Number.isFinite(NaN)); //NaN falseconsole.log(&apos;1/0&apos;,Number.isFinite(&apos;true&apos;/0)); //1/0 falseconsole.log(&apos;NaN&apos;,Number.isNaN(NaN)); NaN true 12345//判断这个数是不是一个整数console.log(&apos;25&apos;,Number.isInteger(25)); //25 trueconsole.log(&apos;25.0&apos;,Number.isInteger(25.0)); //25.0 trueconsole.log(&apos;25.1&apos;,Number.isInteger(25.1)); //25.1 falseconsole.log(&apos;25字符串&apos;,Number.isInteger(&apos;25&apos;)); //&apos;25&apos; false 123console.log(&apos;最大上限:&apos;,Number.MAX_SAFE_INTEGER,&apos;最小下限:&apos;,Number.MIN_SAFE_INTEGER);console.log(&apos;10&apos;,Number.isSafeInteger(10)); //10 trueconsole.log(&apos;a&apos;,Number.isSafeInteger(&apos;a&apos;)); //a false 123//取小数的整数部分(常用)console.log(&apos;4.1&apos;,Math.trunc(4.1)); // 4.1 4console.log(&apos;4.9&apos;,Math.trunc(4.9)); //4.9 4 123456//判断是否为正数、负数、0 返回值分别为1、-1、0console.log(&apos;-5&apos;,Math.sign(-5)); //-5 -1console.log(&apos;0&apos;,Math.sign(0)); //0 0console.log(&apos;5&apos;,Math.sign(5)); //5 1console.log(&apos;50&apos;,Math.sign(&apos;50&apos;));//自动把&apos;50&apos;字符串转换为数值再进行判断 //&apos;50&apos; 1console.log(&apos;foo&apos;,Math.sign(&apos;foo&apos;)); //foo NaN 123//立方根console.log(&apos;-1&apos;,Math.cbrt(-1)); //-1 -1console.log(&apos;8&apos;,Math.cbrt(8)); //8 2 第六部分：数组扩展数组新增特性 Array.from Array.of copyWithin find\findIndex fill entries\keys\values includes 123456//把一组数据转成数组let arr = Array.of(3,4,7,9,11);console.log(&apos;arr=&apos;,arr); //arr= [3,4,7,9,11]let empty = Array.of();console.log(&apos;empty&apos;,empty); //empty [] 1234567891011//Array.from:把一些伪数组、集合转换为真正的数组let p = document.querySelectorAll(&apos;p&apos;);let pArr = Array.from(p);console.log(pArr);pArr.forEach(function(item) &#123; console.log(item.textContent);&#125;)//类似与map的作用console.log(Array.from([1,3,5],function(item) &#123; return item * 2;&#125;)); 123//填充数组console.log(&apos;fill-7&apos;,[1,&apos;a&apos;,undefined].fill(7)); //fill-7 [7,7,7]console.log(&apos;fill,pos&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,3)); //fill,pos [&apos;a&apos;,7,7] 1234567891011121314151617181920//遍历新方法for (let index of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].keys()) &#123; console.log(&apos;keys&apos;,index);&#125;//keys 0//keys 1//keys 2//要babel-polyfill，不然不支持for (let value of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].values()) &#123; console.log(&apos;values&apos;,value);&#125;//values 1//values c//values ksfor (let [index,value] of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].entries()) &#123; console.log(&apos;values&apos;,index,value);&#125;//values 0 1//values 1 c//values 2 ks 12//在当前数组内部把指定位置的成员复制到其他位置（使用场景不多，使用频率不高）console.log([1,2,3,4,5].copyWithin(0,3,4)); //[4,2,3,4,5] 1234567//查找 功能更强console.log([1,2,3,4,5,6].find(function(item) &#123; return item &gt; 3;&#125;)); //4（找到第一个满足条件的数组成员，不继续往后查找）console.log([1,2,3,4,5,6].findIndex(function(item) &#123; return item &gt; 3;&#125;)); //3 （找到第一个满足条件的数组成员，不继续往后查找，返回这个成员的索引位置） 123//和find差不多的作用，不过实用效果更好,可以判断NaNconsole.log(&apos;number&apos;,[1,2,NaN].includes(1)); //number trueconsole.log(&apos;number&apos;,[1,2,NaN].includes(NaN)); //number true 第七部分：函数扩展函数新增特性 参数默认值 rest参数 扩展运算符 箭头函数 this绑定 尾调用 参数默认值123456//默认值后面不能再有没有默认值的变量!!!function test(x,y = &apos;world&apos;) &#123; console.log(&apos;默认值&apos;,x,y);&#125;test(&apos;hello&apos;); //hello worldtest(&apos;hello&apos;,&apos;kill&apos;); //hello kill 与作用域相关的1234567891011let x = &apos;test&apos;;function test2(x,y = x) &#123; console.log(&apos;作用域&apos;,x,y);&#125;test2(&apos;kill&apos;); //作用域 kill killtest2(); //作用域 undefined undefinedfunction test3(c,y = x) &#123; console.log(&apos;作用域&apos;,c,y);&#125;test3(&apos;kill&apos;); //作用域 kill test rest参数1234567891011function test4(...arg) &#123; for (let v of arg) &#123; console.log(&apos;rest&apos;,v); &#125;&#125;test4(1,2,3,4,&apos;a&apos;); //rest 1//rest 2//rest 3//rest 4//rest a 扩展运算符12console.log(...[1,2,4]); //1 2 4console.log(&apos;a&apos;,...[1,2,4]); //a 1 2 4 箭头函数12345//箭头函数注意this绑定let arrow = v =&gt; v*2;let arrow2 = () =&gt; 5;console.log(&apos;arrow&apos;,arrow(3)); //arrow 6console.log(&apos;arrow2&apos;,arrow2()); //arrow2 5 尾调用：好处（提升性能）123456789//存在于函数式编程//函数的最后一句话是不是一个函数function tail(x) &#123; console.log(&apos;tail&apos;,x);&#125;function fx(x) &#123; return tail(x);&#125;fx(123); //tail 123 第八部分：对象扩展函数新增特性 简洁表示法 属性表达式 扩展运算符 Object新增方法 简洁表示法123456789101112131415161718192021222324let o = 1;let k = 2;let es5 = &#123; o: o, k: k&#125;;let es6 = &#123; o, k&#125;console.log(es5,es6); //&#123;k:2,o:1&#125; &#123;k:2,o:1&#125;let es5_method = &#123; hello: function() &#123; console.log(&apos;hello&apos;); &#125;&#125;;let es6_method = &#123; hello() &#123; console.log(&apos;hello&apos;); &#125;&#125;;es5_method.hello(); //helloes6_method.hello(); //hello 属性表达式123456789let a = &apos;b&apos;;let es5_obj = &#123; a: &apos;c&apos;, b: &apos;c&apos;&#125;;let es6_obj = &#123; [a]: &apos;c&apos;&#125;;console.log(es5_obj,es6_obj); &#123;a:&apos;c&apos;,b:&apos;c&apos;&#125; &#123;b:&apos;c&apos;&#125; 12345678910111213//新增API//is 判断两个值是否相等console.log(&apos;字符串&apos;,Object.is(&apos;abc&apos;,&apos;abc&apos;),&apos;abc&apos; === &apos;abc&apos;); //true trueconsole.log(&apos;数组&apos;,Object.is([],[]),[] === []); //false false 注意数组是引用类型//浅拷贝（只拷贝自身的属性，继承的不拷贝、还有不可枚举的属性也不拷贝）console.log(&apos;拷贝&apos;,Object.assign(&#123;a: &apos;a&apos;&#125;,&#123;b: &apos;b&apos;&#125;)); //&#123;a:&apos;a&apos;,b:&apos;b&apos;&#125;let test = &#123;k: 123,o: 456&#125;;for (let [key,value] of Object.entries(test)) &#123; console.log([key,value]);&#125;// [&apos;k&apos;,123]// [&apos;o&apos;,456] 12345678//babel不支持，实用性也用不到//扩展运算符let &#123;a,b...c&#125; = &#123;a: &apos;test&apos;,b: &apos;kill&apos;,c: &apos;ddd&apos;,d: &apos;ccc&apos;&#125;;//c的值如下：//c = &#123;// c: &apos;ddd&apos;,// d: &apos;ccc&apos;//&#125; 第九部分：SymbolSymbol的概念这种数据类型提供一个独一无二的值 Symbol的作用123456789//声明let a1 = Symbol();let a2 = Symbol();console.log(a1 === a2); //false//另一种声明方式//这里a3是一个key值，用Symbol.for声明这个独一无二的值时会先去全局注册，如果注册过，返回那个值，如果没注册，则调用Symbol生成一个独一无二的值。let a3 = Symbol.for(&apos;a3&apos;);let a4 = Symbol.for(&apos;a3&apos;);console.log(a3 === a4); //true 应用场景：12345678910111213141516171819202122232425let a1 = Symbol.for(&apos;abc&apos;);let obj = &#123; [a1]: &apos;123&apos;, &apos;abc&apos;: 345, &apos;c&apos;: 456&#125;;console.log(&apos;obj&apos;,obj); //obj &#123;Symbol(abc):&apos;123&apos;,abc:345,c:456&#125;//通过Symbol定义的属性，for in 和let of取不到该属性for (let [key,value] of Object.entries(obj)) &#123; console.log(&apos;let of&apos;,key,value);&#125;// let of abc 345// let of c 456API:getOwnPropertySymbols获取到的是一个数组（只拿到Symbol类型的属性）Object.getOwnPropertySymbols(obj).forEach(function(item) &#123; console.log(obj[item]);&#125;);// 123//取到所有属性，包括Symbol类型Reflect.ownKeys(obj).forEach(function(item) &#123; console.log(&apos;ownKeys&apos;,item,obj[item]);&#125;);//ownKeys abc 345//ownKeys c 456//ownKeys Symbol(abc) 123 第十部分：数据结构 Set的用法 WeakSet的用法 Map的用法 WeakMap的用法 Set的定义：1234let list = new Set();list.add(5);list.add(7);console.log(&apos;size&apos;,list.size); //size 2 123let arr = [1,2,3,4,5];let list = new Set(arr);console.log(&apos;size&apos;,list.size); //size 5 1234567891011//Set数据类型中元素必须唯一的let list = new Set();list.add(1);list.add(2);list.add(1);console.log(&apos;list&apos;,list); //list Set&#123;1，2&#125;//去重let arr = [1,2,3,1,&apos;2&apos;];let list2 = new Set(arr);console.log(&apos;unque&apos;,list2); //unque Set&#123;1，2，3,&apos;2&apos;&#125; 1234567//Set的添加、删除、清空let arr = [&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;];let list = new Set(arr);console.log(&apos;has&apos;,list.has(&apos;add&apos;)); //has trueconsole.log(&apos;delete&apos;,list.delete(&apos;add&apos;),list); //delete true Set&#123;&quot;delete&quot;,&quot;clear&quot;,&quot;has&quot;&#125;list.clear();console.log(&apos;list&apos;,list); //list Set&#123;&#125; 1234567891011121314151617181920212223242526272829303132//Set的遍历let arr = [&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;];let list = new Set(arr);for (let key of list.keys()) &#123; console.log(&apos;keys&apos;,key);&#125;//keys add//keys delete//keys clear//keys hasfor (let value of list.values()) &#123; console.log(&apos;values&apos;,value);&#125;//values add//values delete//values clear//values hasfor (let [key,value] of list.entries()) &#123; console.log(&apos;entries&apos;,key,value);&#125;//entries add add//entries delete//entries clear//entries haslist.forEach(function(item) &#123; console.log(item);&#125;);//add//delete//clear//has WeakSet 123456//WeakSet中的元素只能是对象 对象都是弱引用，不会被垃圾回收机制检测//没有size属性,没有clear方法，不能遍历let weaklist = new WeakSet();let arg = &#123;&#125;;weaklist.add(arg);console.log(&apos;weakList&apos;,weaklist);//weakList WeakSet&#123;Object&#123;&#125;&#125; Map //Map的基本定义 var map = new Map(); let arr = [&apos;123&apos;]; map.set(arr,456); console.log(&apos;map&apos;,map,map.get(arr)); //map Map{[&apos;123&apos;] =&gt; 456} 456 //第二种定义方法 let map = new Map([[&apos;a&apos;,123],[&apos;b&apos;,456]]); console.log(&apos;map&apos;,map); //map Map{&quot;a&quot; =&gt; 123,&quot;b&quot; =&gt; 456} console.log(&apos;size&apos;,map.size); //size 2 console.log(&apos;delete&apos;,map.delete(&apos;a&apos;),map); //delete true Map{&quot;b&quot; =&gt; 456} console.log(&apos;clear&apos;,map.clear(),map); //clear undefined Map{} 遍历和Set一样WeakMap //接收的key值必须是对象，也没有size属性，没有clear方法，不能遍历 let weakmap = new WeakMap(); let o = {}; weakmap.set(o,123); console.log(weakmap); //WeakMap {…} =&gt; 123 console.log(weakmap.get(o)); //123]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON高程笔记]]></title>
    <url>%2F2017%2F12%2F21%2FJSON(%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0)%2F</url>
    <content type="text"><![CDATA[勿忘初心。 JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据。关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。语法JSON的语法可以表示以下三种类型的值。简单值:使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持JavaScript中的特殊值undefined。对象:对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。数组:数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型—简单值、对象和数组。JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript中表示数据的某些语法相同，但它并不局限JavaScript的范畴。 简单值最简单的JSON数据形式就是简单值。例如，下面这个值是有效的JSON数据: 15 这是JSON表示数值5的方式。类似地，下面是JSON表示字符地方式: 1&quot;Hello world!&quot; JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号(单引号会导致语法错误)。布尔值和null也是有效的JSON形式。但是，在实际应用中，JSON更多地用来表示更复杂地数据结构，而简单值只是整个数据结构中的一部分。 对象JSON中的对象与JavaScript字面量稍微有一些不同。下面是一个JavaScript中的对象字面量: 1234var person = &#123; name:&quot;Nicholas&quot;, age:29&#125;; 这虽然是开发人员在JavaScript中创建对象字面量的标准方式，但JSON中的对象要求给属性加引号。实际上，在JavaScript中，前面的字面量完全可以写成下面这样: 1234var object = &#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29&#125; JSON表示上述对象的方式如下： 1234&#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29&#125; 与JavaScript的对象字面量相比，JSON对象有两个地方不一样。首先，没有声明变量(JSON中没有变量的概念。)其次，没有末尾的分号(因为这不是JavaScript语句，所以不需要分号)。再说一遍，对象的属性必须加双引号，这在JSON中是必须的。属性的值可以是简单值，也可以是复杂类型值，因此可以像下面这样在对象中嵌入对象: 12345678&#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29, &quot;school&quot;: &#123; &quot;name&quot;:&quot;Merrimack College&quot;, &quot;location&quot;:&quot;North Andover,MA&quot; &#125;&#125; 这个例子在顶级对象中嵌入了学校(“school”)信息。虽然有两个”name”属性，但由于它们分别属于不同的对象，因此这样完全没有问题。不过，同一个对象中绝对不应该出现两个同名属性。与JavaScript不同，JSON中对象的属性名任何时候都必须加双引号。手工编写JSON时，忘了给对象属性名加双引号或者把双引号写成单引号都是常见的错误。 数组JSON中的第二种复杂数据类型是数组。JSON数组采用的就是JavaScript中的数组字面量形式。例如，下面是JavaScript中的数组字面量: 1var values = [25,&quot;hi&quot;,true]; 在JSON中，可以采用同样的语法表示同一个数组： 1[25,&quot;hi&quot;,true] 同样要注意，JSON数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。对象和数组通常是JSON数据格式的最外层形式(当然，这不是强制规定的)，利用它们能够创造出各种各样的数据结构。 解析与序列化JSON对象早期的JSON解析器基本上就是eval()函数。由于JavaScript语法的子集，因此eval()函数可以解析、解释并返回JavaScript对象和数组。ECMAScript5对解析JSON的行为进行规范，定义了全局对象JSON。使用eval()对JSON数据结构求值存在风险，因为可能会执行一些恶意代码。JSON对象有两个方法:stringify()和parse()。在最简单的情况下，这两个方法分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值。例如 123456789var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C.Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book); 这个例子使用JSON.stringify()把一个JavaScript对象序列化为一个JSON字符串，然后将它保存在变量jsonText中。默认情况下，JSON.stringify()输出的JSON字符串不包含任何空格字符或缩进，因此保存在jsonText中的字符串如下所示： 1&#123;&quot;title&quot;:&quot;Professional&quot;,&quot;authors&quot;:[&quot;Nicholas C.Zakas&quot;],&quot;edition&quot;:3&#125; 在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined的任何属性也都会被跳过。结果中最终都是值为有效的JSON数据类型的实例属性。将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值。例如，使用下列代码就可以创建与book类似的对象: 1var bookCopy = JSON.parse(jsonText); 注意，虽然book与bookCopy具有相同的属性，但它们是两个独立的、没有任何关系的对象。如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。 序列化选项实际上，JSON.stringify()除了要序列化的JavaScript对象外，还可以接受另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制JSON的序列化。1.过滤结果如果过滤器是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。来看下面的例子。 123456789var book = &#123; &quot;title&quot;:&quot;Professional JavaScript&quot;, &quot;authors&quot;:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,[&quot;title&quot;,&quot;edition&quot;); JSON的第二个参数是一个数组，其中包含两个字符串:”title”和”edition”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就会包含这两个属性: 1&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3&#125; 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性(键)名和属性值。根据属性(键)名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。为了改变序列化对象的结果，函数返回的值就是相应键的值。不过要注意，如果函数返回了undefined，那么相应的属性会被忽略。还是看一个例子吧 1234567891011121314151617181920var book = &#123; title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot;, ], editor:3, year:2011&#125;;var jsonText = JSON.stringify(book,function(key,value) &#123; switch(key) &#123; case &quot;authors&quot;: return value.join(&quot;,&quot;); case &quot;year&quot;: return 5000; case &quot;edition&quot;: return undefined; default: return value; &#125;&#125;); 这里函数过滤器根据传入的键来决定结果。如果键为”authors”,就将数组连接为一个字符串;如果键为”year”,则将其值设置为5000；如果键为”edition”,通过返回undefined删除该属性。最后，一定要提供default项，此时返回传入的值，以便其他值都能正常出现在结果中。实际上，第一次调用这个函数过滤器，传入的键是一个空字符串，而值就是book对象。序列化后的JSON字符串如下所示： 1&#123;”title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000&#125; 2.字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每一个级别缩进的空格数。例如，要在每个级别缩进4个空格，可以这样写代码： 123456789var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,null,4); 保存在jsonText中的字符串如下所示： 12345678&#123; “title&quot;:&quot;Professional JavaScript&quot;, &quot;authors&quot;:[ &quot;Nicholas C. Zakas&quot; ], &quot;edition&quot;:3, &quot;year&quot;:2011&#125; 不知道读者注意到没有，JSON.stringify()也在结果字符串中插入了换行符以提高可读性。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。(只缩进而不换行意义不大)最大缩进空格数为10，所有大于10的值都会自动转换为10。如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用做缩进字符(不再使用空格)。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符。 1var jsonText = JSON.stringify(book,null,&quot;--&quot;); 这样，jsonText中的字符串将变成如下所示： 12345678&#123;--&quot;title&quot;:&quot;Professional JavaScript&quot;,--&quot;authors&quot;:[----&quot;Nicholas C. Zakas&quot;--],--&quot;edition&quot;:3,--&quot;year&quot;:2011&#125; 3.toJSON()方法有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义toJSON()方法，返回其自身的JSON数据格式。原生Date对象有一个toJSON()方法，能够将JavaScript的Date对象自动转换成ISO 8601日期字符串(与在Date对象上调用toISOString()的结果完全一样)。可以为任何对象添加toJSON()方法，比如： 123456789101112var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, toJSON:function() &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book); 以上代码在book对象上定义了一个toJSON()方法，该方法返回图书的书名。与Date对象类似，这个对象也将被序列化为一个简单的字符串而非对象。可以让toJSON()方法返回任何值，它都能正常工作。比如。可以让这个方法返回undefined，此时如果包含它的对象嵌入在另一个对象中，会导致它的值变成null，而如果它是顶级对象，结果就是undefined。 toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设把一个对象传入JSON.stringify(),序列化对象的顺序如下： 如果存在toJSON()方法而且能够通过它取得有效的值，则调用该方法。否则，返回对象本身。 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第1步返回的值。 对第2步返回的每个值进行相应的序列化。 如果提供了第三个参数，执行相应的格式化。 无论是考虑定义toJSON()方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺序都是至关重要的。解析选项JSON.parse()方法也可以接受另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别JSON.stringify()接收的过滤函数，这个函数被称为还原函数，但实际上这两个函数的签名是相同的–它们都接收两个参数，一个键和一个值，而且都需要返回一个值。如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将日期字符串转换为Date对象时，经常要用到还原函数。例如： 123456789101112131415161718var books = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, releaseDate:new Date(2011,11,1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText,function(key,value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);console.log(bookCopy.releaseDate.getFullYear());]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编写可维护的代码]]></title>
    <url>%2F2017%2F12%2F05%2FJavaScript%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[勿忘初心。 基本的格式化缩进层级4个空格缩进，最好统一tab为4个字符。 语句结尾结尾分号 产生错误的例子 123456789101112131415//原始代码function getData() &#123; return &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot; &#125;//分析器会它理解function getData() &#123; return; &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot; &#125;;&#125; 可以通过将左花括号移至与return同一行的位置来修复这个问题。 1234567//这段代码工作正常，尽管没有用分号function getData() &#123; return &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas &#125;&#125; 行的长度80个字符 换行通常我们会在运算符后换行，下一行会增加两个层级的缩进（8个字符） 例外：当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐，例如 12var result = something + antherThing + yetAnotherThing + somethingElse + anotherSomethingElse; 空行 在方法之间 在方法的局部和语句之间 在多行或单行注释之前 在方法内的逻辑片段之间插入空行，提高可读性 命名驼峰命名法 驼峰式大小写命名是由小写字母开始的，后续每个单词首字母都大写。 变量和函数变量名应当总是遵循驼峰小大写命名法，并且前缀是名词。以名词作为前缀可以让变量和函数区分开来，因为函数名前缀应当是动词。 123456789101112131415//好的写法var count = 10;var myName = &quot;Nicholas&quot;;var found = true;//不好的写法:变量像函数var getCount = 10;var isFound = true;//好的写法function getName() &#123; return myName;&#125;//不好的写法:函数看起来像变量function theName() &#123; return myName;&#125; 动词常见的约定 动词 含义 can 函数返回一个布尔值 has 函数返回一个布尔值 is 函数返回一个布尔值 get 函数返回一个非布尔值 set 函数用来保存一个值 常量在ECMAScript6，JavaScript中并没有真正的常量的概念。然而，为了区分普通的变量和常量，它使用大写字母和下划线来命名。 构造函数在JavaScript中，构造函数只不过是前面冠以new运算符的函数，用来创建对象。语言本身已经包含了很多内置构造函数，比如Object和RegExp,同样开发者也可以创建自己的构造函数来生成新类型。 12345678//好的做法function Person() &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var me = new Person(&quot;Nicholas&quot;); 直接量字符串1234//合法的JavaScript代码var name = &quot;Nicholas says,\&quot;Hi.\&quot;&quot;;//也是合法JavaScript代码var name = &apos;Nicholas says.&quot;Hi&quot;&apos;; 在这段代码中，在使用双引号括起来的字符串里需要对双引号进行转义，而在使用单引号括起来的字符串里则不必如此。 nullnull是一个特殊值，但我们常常误解它，将它和undefined搞混。在下列场景中应当使用null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，用作参数传入。 当函数的返回值期望是对象时，用作返回值传出。 还有下面一些场景不应当使用null 不要使用null是否传入了某个参数。 不要用null来检测一个未初始化的变量。 示例代码 1234567891011121314151617181920212223242526//好的用法var person = null;//好的用法function getPerson() &#123; if (condition) &#123; return new Person(&quot;Nicholas&quot;); &#125; else &#123; return null; &#125;&#125;//好的用法var person = getPerson();if (person !== null) &#123; doSomething();&#125;//不好的写法:用来和未初始化的变量比较var person;if (person != null) &#123; doSomething();&#125;//不好的写法:检测是否传入了参数function doSomething(arg1,arg2,arg3,arg4) &#123; if (arg4 != null) &#123; doSomethingElse(); &#125;&#125; 理解null最好的方式是将它当作对象的占位符。这个规则在所有的主流编程规范中都没有提及，但对于全局可维护性来说至关重要。 对象直接量创建最流行的一种做法是使用对象直接量，在直接量上中直接写出所有属性，这种方式可以取代先显示地创建Object的实例然后添加属性的这种做法。 123456789//不好的写法var book = new Object();book.title = &quot;Maintainable JavaScript&quot;;book.author = &quot;Nicholas C. Zakas&quot;;//好的写法var book = &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot;&#125;; 数组直接量和对象直接量类似，数组直接量是JavaScript中定义数组最简洁的一种方式。 123456//不好的写法var colors = new Array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;);var numbers = new Array(1,2,3,4);//好的做法var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];var numbers = [1,2,3,4];]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IndexedDB详细介绍]]></title>
    <url>%2F2017%2F11%2F10%2FIndexedDB%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[勿忘初心。 IndexedDB介绍： IndexedDB是在浏览器中保存结构化数据的一种数据库。替代目前已被废弃的Web SQL Database API而出现的，IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在后期执行，然后如果成功则返回结果。差不多每一次IndexedDB操作，都需要你注册onerror或onsuccess事件处理程序，以确保适当地处理结果。 Indexed将是一个作为API宿主的全局对象。 首先第一步是要打开它indexeDB.open();如果传入的数据库已经存在，就会发送一个打开它的请求；如果传入的数据的数据库不存在，就会发送一个创建并打开它的请求。执行如下代码 12var request = indexedDB.open(&quot;admin&quot;);console.log(request); 效果如下调用indexDB.open();返回了一个IDBOpenDBRequest对象，可以看到这个对象上的onerror、onsuccess、onupgradeneeded事件都为空，result显示的是创建成功了的IndexDB数据库的实例，但是这个实例我们要取到的话，只能在onsuccess事件中，测试代码 123456var db;var request = indexedDB.open(&quot;admin&quot;);request.onsuccess = function() &#123; db = event.target.result; console.log(db);&#125; 效果如下：从图中，我们可以看到我们创建的数据库实例，名字为admin，objectStoreNames是这个数据库中的储存空间的名字，里面为空，后面会解释这个，版本默认设置了1 对象储存空间 即上面的objectStoreNames中的内容，这个空间中是我们储存数据的地方，如何向数据库中创建这个存储空间，这就要在onupgradeneeded事件中进行，但是要触发这个事件，就是要更新数据库的版本号，新打开的版本号要大于默认版本号，测试代码如下 1234567891011121314151617181920212223242526272829303132var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125; 效果如下： 从这两张图可以看出我们在名为admin的数据库中创建了users的储存空间，分别储存了三个对象，第一张图中，可以看到indexName为空，这个是索引，是我们之后要介绍的内容，这里先知道下，keyPath是键值，用对象中的username，以便我们查询，添加之类操作获取对象的通行证，当然前面的索引也是对这个的一个加强，我们默认会设置一个键，但是可以利用索引再创建其他副键，以便方便数据库操作，后面会做介绍，我们还可以看到name为”users”,transaction是事务，基本来说我们后续的操作都要围绕事务来进行，下面我们来说事务。 事务在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125;//事务相关的操作//跟据键值获取对象function getData() &#123; var transaction = db.transaction(&quot;users&quot;,&apos;readwrite&apos;); var store = transaction.objectStore(&quot;users&quot;); var request = store.get(&quot;007&quot;); request.onsuccess = function(event) &#123; var result = event.target.result; console.log(result.firstName); &#125;;&#125;//因为这里要调用onsucess时候保存的db的实例，但是因为异步操作，如果不用超时调用，可能db还没有获取到！setTimeout(function() &#123; getData();&#125;,500); 结果我将操作都一次性写出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125;//事务相关的操作//跟据键值获取对象function getData() &#123; var transaction = db.transaction(&quot;users&quot;,&apos;readwrite&apos;); var store = transaction.objectStore(&quot;users&quot;); var request = store.get(&quot;007&quot;); request.onsuccess = function(event) &#123; var result = event.target.result; console.log(result.firstName); &#125;;&#125;//更新function updataData() &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); var request = store.get(&apos;007&apos;); request.onsuccess = function() &#123; var result = event.target.result; result.firstName = &apos;jack&apos;; store.put(result); &#125;;&#125;//删除function deleteData(key) &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); store.delete(key);&#125;//添加function addData() &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); store.add(&#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot;&#125;);&#125;//因为这里要调用onsucess时候保存的db的实例，但是因为异步操作，如果不用超时调用，可能db还没有获取到！setTimeout(function() &#123; updataData();&#125;,500); 先测试将键值为”007”的对象的firstName属性改为jack结果然后来删除键值为”007”的对象代码 123setTimeout(function() &#123; deleteData(&quot;007&quot;);&#125;,500); 结果删除成功 测试添加功能 123setTimeout(function() &#123; addData();&#125;,500); 结果 好了，现在创建数据库，给数据库存内容，实现了基本的增删改查。下面介绍游标查询 使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。 在对象存储空间上调用openCursor()方法可以创建游标。与IndexedDB中的其他操作一样，openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理程序。 代码 123456789101112//打开游标function openCursor() &#123; var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;); var request = store.openCursor(); request.onsuccess = function() &#123; var cursor = event.target.result; if (cursor) &#123; console.log(cursor.key); cursor.continue(); &#125; &#125;; &#125; 测试 键范围使用游标总让人觉得不那么理想，因为通过游标查找数据的方式太有限了。键范围（Keyrange）为使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。 有四种定义键范围的方式。1. 第一种是使用only()方法，传入你想要取得的对象的键 var onlyRange = IDBKeyRange.only(&quot;007); 2. 第二种定义键范围的方式是指定结界集的下界 var lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;);` 如果你想忽略键为&quot;007&quot;的对象，从它的下一个对象开始，那么可以传入第二个参数true； 3.第三种定义键范围的方式是指定结界集的上界 var lowerRange = IDBKeyRange.upperBound(&quot;ace&quot;); 如果你不想包含键为指定值的对象，同样，可以传入第二个参数true 4.第四种定义键范围的方式，就是同时指定上、下界。使用bound()方法。这个方法可以接受4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过上界的布尔值。 索引（后续补充）补充说明：我是在高程书上学的indexedDB,其中有一处问题，新版本的IndexedDB规范不支持调用setVersion()方法为数据库指定一个版本号，代替的方法是在open()的时候结合传入表示版本号的字符串，同时使用onupgradeneeded事件代替setVersion()方法。onupgradeneeded事件会在onsuccess之前被调用 还有就是游标查询的更新和删除出现问题，我还未解决，所以不做示例。（因为是很多都是用自己理解的方式解释，有不严谨的地方，望谅解） IndexedDB的其他解释博客 谦行大牛博客 张鑫旭大牛博客 范圣刚博客]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>indexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display:none的验证]]></title>
    <url>%2F2017%2F11%2F03%2Fdisplay-none%E7%9A%84%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[勿忘初心。 display：none；的验证结果是该元素所占空间消失，验证例子为：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width:500px; height:500px; &#125; .num1&#123; background:#000; /*display: none;*/ &#125; .num2&#123; background:blue; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;num1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;num2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果：display设置为none后证明结果：display设置为none时，所占空间消失。但是发现给第二个块元素设置为display为inline-block时并没有与第一个块元素在一行，所以将第一个块元素的display也设置为inline-block时，两个块元素才处于一行。然后想起之前有看过块元素可以和行内元素处于一行，就试了下div后插一个a标签结果： 123&lt;div class=&quot;num1&quot;&gt;&lt;/div&gt;&lt;a href=&quot;###&quot;&gt;111&lt;/a&gt;&lt;div class=&quot;num2&quot;&gt;&lt;/div&gt; 效果：然后去查了下之前行内元素和块元素的概念和相关知识： 行内元素与块元素行内元素也叫内联元素，块元素有点也叫行元素。 行级元素和块级元素 元素是通过display的属性值来划分的：block块元素 inline行内元素 inline-block行内块元素 块级元素具有以下特点：1.总是新行上开始，占据一整行； 2.高度，行高以及外边距和内边距都可控制； 3.宽在未设置情况下与浏览器的宽度一样，与内容无关； 4.它可以容纳内联元素和其他块元素。 行内元素的特点：1.和其他元素都在一行上； 2.内联元素不可以设置宽和高、垂直的margin和padding ！！ 3.宽度只与内容有关； 4.行内元素只能容纳文本和其他行内元素。 元素类型 独占一行 能设置宽高 margin,padding值 块级元素 是 是 四个都可以设置 内联元素 否 否 竖直的不可设置 在查询资料的时候有发现了一个东西就是 p元素内不能嵌套div元素 然后我去做了试验： 1&lt;p&gt;1111&lt;div&gt;222&lt;/div&gt;333&lt;/p&gt; 效果如下：然后查询相关解释：为什么p元素不能嵌套div元素 p元素有默认样式！最好设置margin：0；padding：0； 然后又想到文档流这个概念：html文档流： 自窗体自上而下分成一行一行，并在每行中按从左到右的顺序排放元素。 拓展：inlne-block有几像素的误差！！！ 语义化的好处：1.去掉或样式丢失的时候能让页面呈现清晰的结构。 2.搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。 3.便于团队开发和维护。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css学习笔记]]></title>
    <url>%2F2017%2F10%2F14%2Fhtml-css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[勿忘初心。 css选择器：基础选择器、关系选择器、属性选择器、伪类选择器、伪对象选择器。 关系选择器有如下几种： 包含选择器（EF） 子选择器（E&gt;F） 相邻选择器（E+F） 兄弟选择器（E~F）注意的地方，对它后面的元素起作用。 1.包含选择器符（EF）选择所有被E元素包含的F元素，中间用空格隔开。 12345678ul li&#123; color:red;&#125;&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橙子&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ul&gt; 2.子选择器符（EF）选择所有作为E元素的直接子元素F，对更深一层的元素不起作用，用大于号表示。 12345div&gt;a&#123; color:red; //div下的一级子元素a&#125;&lt;a href=&quot;#&quot;&gt;这是子元素&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;这是子孙元素&lt;/a&gt;&lt;/p&gt; 选择第一个子元素，在bootstrap的源码非常多见。 3.相邻选择器符（E+F）选择紧贴在E元素之后F元素，用加号表示，选择相邻的第一个兄弟元素。 123456p+span&#123; color:red; //只会选中第一个span&#125;&lt;p&gt;这是p元素&lt;/p&gt;&lt;span&gt;这是紧挨着p元素的第一个span&lt;/span&gt;&lt;span&gt;这是第二个span&lt;/span&gt; 4.兄弟选择器符（E~F）选择E元素之后的所有兄弟元素F，作用于多个元素，用~号隔开。 12345678p+span&#123; color:red; //和p之后平级的span元素都被选中了，有几个选几个。&#125;&lt;span&gt;这span在p元素之前不会被选中。&lt;/span&gt;&lt;p&gt;这是p元素&lt;/p&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt; css属性选择器通过html的属性来选择元素，&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;class即是属性，p1是class的属性值。 写法：元素[属性名=&quot;属性值&quot;]，等号不固定，可换其他符号。 E[att] 选择具有att属性的E元素 E[att=”val”] 选择具有att属性且属性值等于val的E元素 E[att~=”val”] 选择有att属性的元素，且属性值列表中有一个符号val E元素。 E[att^=”val”] 选择E元素中有att属性，且以”val”开头的E元素。 E[att$=”val”] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=”val”] 选择具有att属性且属性值包含val的字符串的E元素。 伪类选择器伪类通过冒号来定义，它定义了元素的状态，如点击按下，点击完等等，我们之前都是直接操作元素的样式，使元素看上去更&quot;动态&quot;。 E:link 设置超链接a在未被访问前的样式（特指a标签） E:visited 设置超链接a已被访问过的样式（特指a标签） E:hover 设置鼠标悬浮在元素上时的样式，不限于a标签 E:active 设置元素在鼠标按下时的样式，不限于a标签 E:not(s) 匹配不含有s选择器的元素 E:first-child 父元素的第一个子元素 E:last-child only-child empty checked nth-child(n) 伪对象选择器伪对象也叫伪元素，在过去，伪类和伪元素都被写成前面只加一个冒号，实际上应该:weilei ::weiyuansu，而现在我们为了兼容旧的书写方式，用一个冒号引导伪类也是能被解析的。 伪类一般反映无法在css中轻松或者可靠检测到的某个元素的状态或属性； 伪元素表示DOM外部的某种文档结构 伪类更多是定义元素的状态，而伪元素是改变文档结构，在结构外另加一个没有实际存在的元素（伪元素） 常用伪元素（html之外通过css模拟出一个html结构） 1.E:before/E::before 2.E:after/E::after position定位 position属性是指本体相对于上级的定位，position定位又分绝对定位和相对定位。它的默认值是static，意味着元素没有定位，出现在文档流中应该出现的位置。如果用position来布局页面，父级元素的position属性必须为relative或absolute，行元素加了position:absolute后可设置宽和高（加了float和fixed以后也可以设置宽和高） 常见属性值： static：无特殊定位，对象遵循正常文档流。 relative：对象遵循正常文档流。 absolute：对象脱离正常文档流，使用top、right、bottom、left等属性进行绝对定位。 fixed：对象脱离正常文档流。使用top、right、bottom、left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。IE6及以下不支持此参数值。 static、relative正常文档流 absolute、fixed脱离正常文档流 position绝对定位。设置了绝对定位的元素，他默认参照浏览器的左上角，配合top、right、bottom、left四个属性进行定位。通常我们设置两个值就可以定位，如果四个都写，以左上角（left、top）为准。 清除浮动的三个方法：1.使用伪元素清除浮动123456789101112131415.box::after&#123; content:&quot; &quot;; clear:both; display:block;&#125;.left,.right&#123; width:100px; height:100px; background:#388bff; float:left;&#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 2.使用overflow：hidden清除浮动12345678910111213.box&#123; overflow:hidden; //overflow:auto 也是可以的&#125;.left,.right&#123; width:100px; height:100px; background:#388bff; float:left;&#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 3.使用空div1234.clear&#123; clear:both;&#125;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 能被继承的常用属性：color、cursor、font-family、font-size、font-weight、font、letter-spacing、line-height、list-style、text-align、text-indent 浏览器内核以及其前缀 Gecko内核 前缀为-moz- 火狐浏览器 Webkit内核 前缀为-webkit- chrome浏览器、safari浏览器 Trident内核 前缀为-ms- 也称IE内核 Presto内核 前缀为-o- 只有opera采用，但现在opera使用了有webkit衍生在blink内核 box-shadow：水平阴影的位置 垂直阴影的位置 模糊距离 颜色box-shadow:10px 20px 5px blue; text-shadow(文字阴影)格式同上 css3字体 引用 1234@font-face&#123; font-family:myFirstFont; //你自定义的字体名 src:url(&quot;res/lxksf.ttf&quot;);&#125; 过渡transition书写格式 transition:属性名 时间 速度曲线 何时开始; 最少要包含过渡时间。 转换transform分为2D和3D 2D transform:rotate(0 deg); 3D transform:rotateX(); transform:rotateY(); transform:rotate3d(x,y,z); //z轴一般不用写 动画@keyframes动画名 两种方式1.form to 2.百分比 用@keyframes定义好后通过animation进行引用 animation的可选值可指定这几个值:动画名、动画时长、效果、开始时间 动画示例： 1234567891011121314151617img&#123; width:100px; height:100px; border-radius:50%;&#125;@keyframes CDturn&#123; from&#123; transform:rotate(0 deg); &#125; to&#123; transform:rotate(360 deg); &#125;&#125;img:hover&#123; animation:3s linear infinite CDturn&#125;&lt;img src=&quot;img/cd.png&quot; alt=&quot; &quot; /&gt; 特殊图形三角形 通过border来定义，宽和高要设置为0，另外两面的颜色设置为透明 梯形 通过border来定义，和三角形不同的是要设置宽度。 圆形 宽、高、border-radius：50%; 多列column-count 分几列 column-gap 列间距 column-rule 列分割线的样式 （加前缀:eg；-webkit-） 多行文本框1&lt;textarea name=&quot; &quot; id=&quot; &quot; cols=&quot;30&quot; row=&quot;10&quot;&gt;&lt;/textarea&gt; 补充：resize=none;（不可调大小）模拟出可调大小的： resize:both; overflow:hidden; width:_px; height:_px; border:_ _ _; Box-sizingbox-sizing属性允许你以&quot;W3C的盒模型&quot;或&quot;IE盒模型&quot;来定义元素，以适应区域。换句话说，当前元素使用哪种盒模型，可以由box-sizing属性指定。 它有两个值 content-box（标准） ：padding和border不被包含在width和height内，元素的实际大小为宽高+border+padding，此为标准模型下的盒模型。 border-box（怪异）：padding和border被包含在定义的width和height中，元素实际的大小为你定义了多宽就是多宽。此属性为怪异模式下的盒模型。 meta标签的常用属性http-equiv属性refresh，它指定时间内刷新，并且可能跳转到指定url&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;url=http://www.baidu.com&quot;/&gt;如果只写时间。自动刷新本页面 ####img标签边距问题解决方法 把img标签转化为块元素。 父容器指定高度。 父容器的字号变为font-size：0px; (注意里面的字号要另外设置)]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于响应式网站做的笔记]]></title>
    <url>%2F2017%2F10%2F13%2F%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E7%AB%99%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[勿忘初心。 响应式网站是一个设计理念，它是多项技术的综合体流动网格（弹性网格布局）、弹性图片和媒介查询是响应式互联网设计的三大技术成分优点： 解决了设备只见的差异化展示（让不同的设备达到最优的视觉体验） 减少工作量1、网站、设计、代码、内容都只需要一份 2、多出来的工作量只是JS脚本、CSS样式做一些改动 节省时间 每个设备都能得到正确的设计 搜索优化缺点： 会加载更多的样式和脚本资源 设计比较难精确定位和控制 老版本浏览器兼容不好设计实践原则 progressive enhancement 渐进增强 （不适用） graceful degradation 优雅降级（更好）移动优先： 在设计的初期就要考虑的页面如何在多终端展示断点的选择：0-480（小屏幕）、 481-800（中屏幕）、 801-1400（大屏幕）、 1400+（巨屏幕） 移动webPixel 移动开发像素知识px：css pixels 逻辑像素，浏览器使用的抽象单位 dp,pt:device independent pixels 设备无关像素 dpr:devicePixelRatio 设备像素缩放比 计算公式: 平面上：1px = (dpr)^2 * dp 纬度上：1px = dpr * dp DPI:打印机每英寸可以喷的墨汁点（印刷行业） PPI：屏幕每英寸的像素数量，即单位英寸内的像素密度 PPI越高，像素数越高，图像越清晰，但可视度越低（小），系统默认设置缩放比越大 Retina（高清屏）: dpr都是大于等于2]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记]]></title>
    <url>%2F2017%2F10%2F12%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[勿忘初心。 ECMAScript篇：defer属性和async属性只适用于外部脚本文件ECMAScript中的一切（变量、函数名、和操作符）都区分大小写。标识符：就是指变量、函数、属性的名字或者函数的参数。按照惯例ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩余的每个单词的首字母大写。要在整个脚本中启用严格模式，可以在顶部添加如下代码：&quot;use strict&quot;(这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示，用于告诉支持的JavaScript引擎切换到严格模式) ECMAScript中的5种简单数据类型：Undefined、Null、Boolean、Number和String.复杂数据类型：Object（本质名值对）null表示一个空对象指针（如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值）浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数12345var a = 0.1;var b = 0.2;if (a + b == 0.3) &#123; //不要做这样的测试! alert(&quot;You got 0.3.&quot;);&#125; 但以下代码ok 12345var a = 0.05;var b = 0.25;if (a + b == 0.3) &#123; alert(&quot;You got 0.3.&quot;);&#125; NaN与任何值都不相等，包括NaN本身。1alert(NaN == NaN); //false 用parseInt()转换空字符串会返回NaN 字符串要理解的点：ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，**首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量**。 一元操作符中要注意的（前置和后置）执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。 1234var age = 29;var anotherAge = --age + 2;alert(age); // 输出28alert(anotherAge); //输出30 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。 1234var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //等于22var num4 = num1 + num2; //等于21 在随后的学习中，学习js数据结构列表时，看到一个后置的一元操作符，瞬间觉得这种前置和后置设计的伟大之处。1234/* 给列表添加元素 */function append(element)&#123; this.dataStore[this.listSize++]=element;&#125; 我对这个函数的理解：给当前数组位置存一个新值，然后数组的长度加一，既赋值了当前项，又为下一项的保存预先留个空位。（仅个人理解，如有问题，感谢指出） 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。逻辑或操作符是短路操作符，如果第一个操作数的求值结果为true，就不会对第二个操作数求值。这种可以用于给某变量赋值：（妙用如下） 1var myObject = preferredObject || backupObject; 我的理解：为了让某个变量赋值的保险起见，一般逻辑或前面的基本都会存在，如果不存在，为其赋值后面一个，加个保险。（仅个人理解，如有问题，感谢指出） 相等操作符：注意“==”和“===”记住：null == undefined会返回true,因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。 break和continue语句 break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。 switch语句在比较值时使用的是全等操作符，因此不会发生类型转换。ECMAScript中所有函数的参数都是按值传递的。使用var声明的变量会自动被添加到最接近的环境中。优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用—这个做法叫做解除引用。（解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收）基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中; 引用类型的值是对象，保存在堆内存中; 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符 instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 为了解决这个问题，ECMAScript5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是哪个全局执行环境中创建的。这个方法的用法如下： 123if (Array.isArray()) &#123; //对数组执行某些操作&#125; 函数名仅仅是指向函数的指针。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。BOM篇（HTML5规范）top对象始终指向最高（最外）层的框架，也就是浏览器窗口。判断页面是否处于标准模式document.compatMode == &quot;CSS1Compat&quot; 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。JavaScript是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 DOM篇NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。我们常说，NodeList是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。由于IE没有公开Node类型的构造函数，为了确保跨浏览器兼容，最好还是将nodeType属性与数字值进行比较。appendChild()、insertBefore()、replaceChild()、removeChild()这四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用parentNode属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用这些方法，将会导致错误。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin-top的问题]]></title>
    <url>%2F2017%2F10%2F12%2Fmargin-top%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[勿忘初心。 一个div内嵌套一个div，如果给内部div设置margin-top，理论上，外部div位置不变，内部div相对向下移动。（但有个前提是，外部的div未设置border和padding）未设置margin-top的情况：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;margin-top的问题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0px; padding: 0px; &#125; .outside&#123; width:200px; height:200px; background-color: blue; &#125; .inside&#123; /*margin-top:20px;*/ width:100px; height:100px; background-color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outside&quot;&gt; &lt;div class=&quot;inside&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在把magrin-top的注释取消：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;margin-top的问题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0px; padding: 0px; &#125; .outside&#123; width:200px; height:200px; background-color: blue; &#125; .inside&#123; margin-top:20px; width:100px; height:100px; background-color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outside&quot;&gt; &lt;div class=&quot;inside&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 理论上应该是下面这种情况：这个问题我在5大主浏览器上试过，发现均出现这种情况：然后上网查询，找到了一段对这个描述最清楚的解释。 父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己“领导”(父元素，祖先元素)的麻烦。解决办法如下：1.给外部div设置border-bottom:0.1px solid #000; 2.或者设置padding-bottom:0.1px; 3.给设置maigin-top的div设置overflow:hidden.]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
