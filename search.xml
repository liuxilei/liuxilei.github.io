<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MDN学习笔记]]></title>
    <url>%2F2018%2F05%2F02%2FMDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[岁月还长，你心地善良，终会有一人陪你骑马喝酒走四方…… HTML部分空元素 不是所有元素都拥有开始标签，内容和结束标记. 一些元素只有一个标签，通常用来在此元素所在位置插入/嵌入一些东西 。例如：元素&lt;img&gt;是用来在元素&lt;img&gt;所在位置插入一张指定的图片。 提示：Empty elements 有时也被叫作 void elements.布尔属性 有时你会看到没有值的属性，它是合法的。这些属性被称为布尔属性，他们只能有跟它的属性名一样的属性值。例如 disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)，此时用户不能向他们输入任何数据。HTML中的空白 无论你用了多少空白(包括空白字符，包括换行), 当渲染这些代码的时候，HTML解释器会将连续出现的空白字符减少为一个单独的空格符。那么为什么我们会使用那么多的空白呢? 答案就是为了可读性 —— 如果你的代码被很好地进行格式化，那么就很容易理解你的代码是怎么回事, 反之就只有聚做一团的混乱. 在我们的HTML代码中，我们让每一个嵌套的元素以两个空格缩进。 你使用什么风格来格式化你的代码取决于你 (比如所对于每层缩进使用多少个空格),但是你应该坚持使用某种风格。 元数据许多meta元素包含了name和content特性： name特性指定了meta 元素的类型; 说明该元素包含了什么类型的信息。 content指定了实际的元数据内容。 超链接使用title属性添加支持信息 您可能要添加到您的链接的另一个属性是标题；这旨在包含关于链接的补充有用信息，例如页面包含什么样的信息或需要注意的事情。 连接的标题仅当鼠标悬停在其上时才会显示，这意味着使用键盘来导航网页的人很难获取到标题信息。如果标题信息对于页面非常重要，你应该使用所有用户能都方便获取的方式来呈现，例如放在常规文本中。文档片段 超链接可以链接到html文档的特定部分（被称为文档片段），而不仅仅是文件的顶部。要做到这一点你必须首先分配一个id属性的元素到链接。通常链接到一个特定的标题是有意义的.]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>MDN</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作第一月总结]]></title>
    <url>%2F2018%2F04%2F05%2F%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[你站在桥上看风景,看风景人在楼上看你,明月装饰了你的窗子,你装饰了别人的梦。 离之前每天图书馆敲代码的日子突然画风一转变成了工作狗，而且我在写这个文章的时候，已经过了一个月了，这一个月发生了很多，比如说为了装xd，我的电脑被基友给清空了，一年学习的很多东西都没了，关键我还想不起是哪些没了，心累啊，面试总结一个、一些常用的demo例子，今日头条大佬的学习笔记也没了，可能还有很多我现在想不起来的，等用到的时候，怕是心累的一匹，现在就把自己这一个月经历的能想到的问题全部写一遍把，以便以后回过头来查看。第一周： 刚进公司，装环境，记得很多都装过了，自信心满满，然后到了配React环境那里，配不来啊，又要测试、又是sass编译，又是上线，各种bug，然后不弄了，觉得花时间在webpack配置上还是先看官方文档，webpack留给后面，先把React的所有特效全部弄一遍，熟悉了一遍当初视频的代码，然后官网文档，这是个特别好的东西，对理解React这块，然后文档越看越难，幸好把基础都过了一遍，然后卡壳到高级那里，然后就开始迷离的生活，然后同事在看React学习之道，我也开始拿起这本书，刷起来里面的代码来，然后，感觉自己写着就写偏了，谢谢我第一周遇到的东西，和问题。写了一个登录界面，需要ajax传递一些数据给后台一些接口，然后报错，就是不行，说本该是整型的数据传递，但传递过去的是字符，这里一脸懵逼，最后看尧哥新写的代码 1234567891011$.ajax(&#123; url: "https://art.ci.better8.cn/api/user/sms", method: "POST", data: &#123; "data": "&#123;\"mobile\":" + phone + ",\"type\":2 &#125;" &#125;, success: function (response) &#123; console.log("短信已发送"); timeout(60); &#125;&#125;); 用转义字符\” 解决了这个问题，这段代码是谷歌浏览器的一个插件自动生成的叫Postman,但是自己模拟接口报错，这里自己需要花时间解决一下。 第二周： 这周感觉也很闲，没做什么，就刷文档，后面尧哥给了一个好多多，关于学生学画画的app，手机介绍页面，这里自己特别高兴，但后面好像有悲伤的故事等着自己，这里有个东西学到了，那就是html中写两个div，一个里面放着pc的页面，一个放着移动端的页面，然后通过js判断，代码如下：123456789101112131415161718192021function isMobile()&#123; let ua = navigator.userAgent; let ipad = ua.match(/(iPad).*OS\s([\d_]+)/), isIphone = !ipad &amp;&amp; ua.match(/(iPhone\sOS)\s([\d_]+)/), isAndroid = ua.match(/(Android)\s+([\d.]+)/), isWeiXin = ua.match(/MicroMessenger/i), isMobile = isIphone || isAndroid || isWeiXin; if (isMobile) &#123; return true; &#125;else &#123; return false; &#125;&#125;$(function() &#123; let key = isMobile(); if (key) &#123; $('.mobile').css('display','block'); &#125; else &#123; $('.container').css('display','block'); &#125;&#125;); 以备以后查看，哈哈，这周没什么大问题 第三周： 哈哈，幸福生活来了，官网要弄，拿react写，具体写的时间星期二晚上开始写的，环境不会配，尧哥帮忙配好，后面这里要花时间去解决，官网react框架写的静态页面，遇到的问题，写好的页面，分辨率的问题，不同分辨率下，炸了，解决方案目前想到的是媒体查询+rem/em;另一种百分比，现在想到最靠谱的就是flex布局加margin/padding解决，目前在学习状态原生实现太多特效，要用state改！动画实现echart看看问题：1.&lt;button&gt;按钮中加入a便签，设置margin，hover时候会缩进，后续用代码现在不想敲字了，哈哈2.margin那个问题，自己第一个博客3.visted、link这两个css属性只能用到a标签上待补充]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识点总结]]></title>
    <url>%2F2018%2F03%2F06%2Fjs%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[那些比你牛逼的人还比你努力。 基础知识原型 原型链作用域 闭包异步 单线程JS APIDOM操作Ajax事件绑定开发环境版本管理模块化打包工具运行环境页面渲染性能优化 先从几道面试题说起 JS中使用typeof能得到哪些类型？（JS变量类型） 何时使用=== 何时使用==？（强制类型转换） window.onload和DOMContentLoaded的区别？（浏览器渲染过程） 用JS创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号（作用域） 简述如何实现一个模块加载器，实现类似require.js的基本功能（JS模块化） 实现数组的随机排序 （JS基础算法） 基础知识 JS中使用typeof能得到哪些类型？ 答：undefined、number、boolean、string、object、function(补充：typeof可以分清值类型，引用类型不行只能判断函数。) 何时使用=== 何时使用==？ 1234if (obj.a == null) &#123; //这里相当于obj.a === null || obj.a === undefined,简写形式 //这是jquery源码中推荐的写法&#125; JS中有哪些内置函数(数据封装类对象) 答：Object、Array、Boolean、Number、String、Function、 Date、RegExp、Error JS变量按照存储方式区分为哪些类型，并描述其特点12345678910111213141516171819202122// 值类型var a = 10;var b = a;a = 11;console.log(b); //10// 引用类型var obj1 = &#123;x:100&#125;var obj2 = obj1;obj1.x = 200;console.log(obj2.x) //200//下面是自己做的练习 以后也要注意！var a = &#123; value: '1111'&#125;;var b = a;console.log(b); //&#123;value:'1111'&#125;console.log(a); //&#123;value:'1111'&#125;var a = &#123; value: 1111&#125;;console.log(b); //&#123;value:'1111'&#125; //这里b还是之前的对象，因为a重新赋予了一个对象指针，所以b的value没发生改变console.log(b === a); //false 值类型可以把数值分块存储在内存中，引用类型是好几个变量共用一个内存块，达到节省内存空间目的；值类型的值赋值之后不会相互干涉，引用类型赋值是变量指针的赋值，并不是真正值的拷贝，它们值的修改是相互干预的。 如何理解JSON JSON只不过是一个JS对象而已;一种数据格式 12JSON.stringify(&#123;a:10,b:20&#125;);JSON.parse('&#123;"a":10,"b":20&#125;'); 变量类型 值类型 vs 引用类型12345/* 值类型 */var a = 100;var b = a;a = 200;console.log(b); //100 123456/* 引用类型 （对象、数组、函数）*/var a = &#123;age:20&#125;var b = a;b.age = 21;console.log(a.age) //21//引用类型有个特点：可以扩展属性，自己做例子发现写函数，函数的name属性为函数名，name无法更改。 typeof运算符详解12345678typeof undefined //undefinedtypeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof &#123;&#125; //objecttypeof [] //objecttypeof null //objecttypeof console.log //function typeof只能区分出值类型的详细类型，引用类型区别不出来。 变量计算强制类型转换（值类型） 字符串拼接 ==运算符 if语句 逻辑运算 字符串拼接12var a = 100 + 10; //110var b = 100 + '10';//'10010' ==运算符123100 == '100' //true0 == '' //truenull == undefined //true if语句123456789101112var a = true;if (a) &#123; //...&#125;var b = 100;if (b) &#123; //...&#125;var c = '';if (c) &#123; //...&#125; 逻辑运算符123456console.log(10 &amp;&amp; 0); //0console.log('' || 'abc'); //'abc'console.log(!window.abc); //true//判断一个变量会被当做true还是falsevar a = 100;console.log(!!a); 原型和原型链 如何准确判断一个变量是数组类型 123var arr = [];console.log(arr instanceof Array);typeof arr //object,typeof是无法判断是否是数组的 写一个原型链继承的例子 123456789101112131415//动物function Animal() &#123; this.eat = function() &#123; console.log('animal eat'); &#125;;&#125;//狗function Dog() &#123; this.bark = function() &#123; console.log('dog bark'); &#125;;&#125;Dog.prototype = new Animal();//哈士奇var hashiqi = new Dog(); 123456789101112131415161718192021222324// 接下来代码演示时，会推荐更加贴近实战的原型继承实例function Elem(id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val) &#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; //链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;;Elem.prototype.on = function(type,fn) &#123; var elem = this.elem; elem.addEventListener(type,fn); return this;&#125;;var div1 = new Elem('div1');console.log(div1.html());div1.html('&lt;p&gt;hello world!&lt;/p&gt;');div1.on('click',function() &#123; alert('clicked');&#125;); 描述new一个对象的过程 12341.创建一个新对象2.this指向这个新对象3.执行代码，即对this赋值4.返回this zeptp(或其他框架)源码中如何使用原型链 阅读源码是高效提高技能的方式 但不能&quot;埋头苦钻&quot;有技巧在其中 慕课网搜索&quot;zepto设计和源码分析&quot; 知识点：构造函数12345678function Foo(name,age) &#123; this.name = name; this.age = age; this.class = 'class-1'; //return this //默认有这一行&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);//创建多个对象 构造函数 - 扩展- var a = {} 其实是 var a = new Object()的语法糖 - var a = [] 其实是 var a = new Array()的语法糖 - function Foo(){...} 其实是var Foo = new Function(...) - 使用instanceof判断一个函数是否是一个变量的构造函数 原型规则和示例 所有的引用类型(数组、对象、函数)，都具有对象特性，即可自由扩展属性(除了”null”意外) 12345678var obj = &#123;&#125;;obj.a = 100;console.log(obj); //&#123;a:100&#125;var arr = [];arr.a = 100;console.log(arr); //[a:100]function fn() &#123;&#125;fn.a = 100; 所有的引用类型(数组、对象、函数)，都有一个__proto__(隐式原型)属性，属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有的函数，都有一个prototype(显式原型)属性，属性值也是一个普通的对象 1console.log(fn.prototype); 所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值 1console.log(obj.__proto__ === Object.prototype); //true 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。 123456789101112131415//构造函数function Foo(name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function() &#123; alert(this.name);&#125;;//创建实例var f = new Foo('zhangsan');f.printName = function() &#123; console.log(this.name);&#125;;//测试f.printName();f.alertName(); this:指向调用者12345678//循环对象自身的属性for (var item in f) &#123; //高级浏览器已经在for in 中屏蔽了来自原型的属性 //但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; 原型链12345678910111213141516//构造函数function Foo(name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function() &#123; alert(this.name);&#125;;//创建实例var f = new Foo('zhangsan');f.printName = function() &#123; console.log(this.name);&#125;;//测试f.printName();f.alertName();f.toString(); //要去f.__proto__.__proto__中查找 instanceof用于判断引用类型属于哪个构造函数的方法 f instanceof Foo的判断逻辑是： f的__proto__一层一层往上，能否对应到Foo.prototype 再试着判断f instanceof Object 作用域和闭包函数声明和函数表达式12345678910111213//全局fn(); //函数声明提升function fn() &#123; //声明&#125;fn1(); //报错console.log(fn1); //undefined 变量提升var fn1 = function() &#123; //表达式&#125;;//var命令会发生变量提升console.log(a); //undefinedvar a = 2; 1234567891011121314151617181920212223fn('zhangsan'); //zhangsan 20function fn(name) &#123; age = 20; console.log(name,age); var age;&#125;fn1('zhangsan');//zhangsan 20//100function fn1(name) &#123; //函数 console.log(this); console.log(arguments); age = 20; console.log(name,age); var age; bar(100); function bar(num) &#123; console.log(num); &#125;&#125; 题目 说一下对变量提升的理解 变量定义 函数声明（注意和函数表达式的区别） 说明this几种不同的使用场景 作为构造函数执行 作为对象属性执行 作为普通函数执行 call apply bind 创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号 123456789101112131415161718192021222324//这是一个错误的写法！var i,a;for (i = 0;i &lt; 10;i++) &#123; a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click',function(e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a);&#125;//这是正确的写法var i;for (i = 0;i &lt; 10;i++) &#123; (function(i) &#123; var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click',function(e) &#123; e.preventDefault(); alert(i); &#125;); document.body.appendChild(a); &#125;)(i)&#125; 如何理解作用域 自由变量 作用域链，即自由变量的查找 闭包的两个场景 实际开发中闭包的应用1234567891011121314151617//闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad() &#123; var _list = []; return function(id) &#123; if (_list.indexOf(id) &gt;= 0) &#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;//使用var fristLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true 知识点 执行上下文 this 作用域 作用域链 闭包 执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 函数：变量定义、函数声明、this、arguments this this要在执行时才能确认值，定义时无法确认12345678910var a = &#123; name: 'A', fn: function() &#123; console.log(this.name); &#125;&#125;;a.fn(); //A this === aa.fn.call(&#123;name:'B'&#125;) //B this === &#123;name:'B'&#125;var fn1 = a.fn;fn1(); //this === window 场景 作为构造函数执行 1234function Foo(name) &#123; this.name = name;&#125;var f = new Foo('zhangsan'); 作为对象属性执行 1234567var obj = &#123; name: 'A', printName: function() &#123; console.log(this.name); &#125;&#125;;obj.printName(); 作为普通函数执行 1234function fn() &#123; console.log(this);&#125;fn(); //this === window call apply bind 12345function fn1(name,age) &#123; alert(name + "," + age); console.log(this);&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22); 12345var fn1 = function(name,age) &#123; alert(name + "," + age); console.log(this);&#125;.bind(&#123;x:100&#125;);fn1('zhangsan',22); 作用域 没有块级作用域 1234567891011if (true) &#123; var name = 'zhangsan';&#125;console.log(name);等同于var name;if (true) &#123; name = 'zhangsan';&#125;console.log(name);//尽量不要在块里声明变量，因为也是全局的，为了可读性，直接在外面声明它是一个全局变量，这样会易于理解。 只有函数和全局作用域 1234567var a = 100;function fn() &#123; var a = 200; console.log('fn',a);&#125;console.log('global',a);fn(); 作用域链12345678var a = 100;function fn() &#123; var b = 200; //当前作用域没有定义的变量，即"自由变量" console.log(a); console.log(b);&#125;fn(); 123456789101112var a = 100;function F1() &#123; var b = 200; function F2() &#123; var c = 300; console.log(a); //a是自由变量 console.log(b); //b是自由变量 console.log(c); &#125; F2();&#125;F1(); 闭包1234567891011function F1() &#123; var a = 100; //返回一个函数（函数作为返回值） return function() &#123; console.log(a); &#125;&#125;//f1得到一个函数var f1 = F1();var a = 200;f1(); 闭包的使用场景 函数作为返回值（上一个demo） 函数作为参数传递（自己思考）123456789101112function F1() &#123; var a = 100; return function() &#123; console.log(a); //自由变量，父作用域寻找 &#125;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn();&#125;F2(f1); 异步和单线程题目 同步和异步的区别是什么？分别举一个同步和异步的例子 同步会阻塞代码执行，而异步不会 alert是同步，setTimeout是异步 一个关于setTimeout的笔试题 123456789console.log(1);setTimeout(function() &#123; console.log(2);&#125;,0);console.log(3);setTimeout(function() &#123; console.log(4);&#125;,1000);console.log(5); 前端使用异步的场景有哪些 定时任务：setTimeout,setInterval 网络请求：ajax请求，动态加载 事件绑定知识点 什么是异步（对比同步） 123456789console.log(100);setTimeout(function() &#123; console.log(200);&#125;,1000);console.log(300);//对比同步console.log(100);alert(200);console.log(300); 何时需要异步 在可能发生的等待的情况 等待过程中不能像alert一样阻塞程序运行 因此，所有的’’等待的情况”都需要异步 前端使用异步的场景 定时任务：setTimeout,setInterval 网络请求：ajax请求，动态加载 事件绑定1234567891011121314151617181920//ajax请求代码示例console.log('start');$.get('./data1.json',function(data1) &#123; console.log(data1);&#125;);console.log('end');//&lt;img&gt;加载示例console.log('start');var img = document.createElement('img');img.onload = function() &#123; console.log('loaded');&#125;img.src = '/xxx.png';console.log('end');//事件绑定示例console.log('start');document.getElementById('btn1').addEventListener('click',function() &#123; alert('clicked');&#125;);console.log('end'); 异步和单线程 12345678910console.log(100);setTimeout(function() &#123; console.log(200);&#125;);console.log(300);//执行第一行，打印100//执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）//执行最后一行，打印300//待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的要执行//发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行 其他知识题目 获取2017-06-10格式的日期 123456789101112131415161718192021function formatDate(dt) &#123; if (!dt) &#123; dt = new Date(); &#125; var year = dt.getFullYear(); var month = dt.getMonth() + 1; var date = dt.getDate(); if (month &lt; 10) &#123; //强制类型转换 month = '0' + month; &#125; if (date &lt; 10) &#123; //强制类型转换 date = '0' + date; &#125; //强制类型转换 return year + '-' + month + '-' + date;&#125;var dt = new Date();var formatDate = formatDate(dt);console.log(formatDate); 获取随机数，要求是长度一致的字符串格式 1234var random = Math.random();random = random + '0000000000'; //后面加上10个零random = random.slice(0,10);console.log(random); 写一个能遍历对象和数组的通用forEach函数 1234567891011121314151617181920212223function forEach(obj,fn) &#123; var key; if (obj instanceof Array) &#123; //准确判断是不是数组 obj.forEach(function(item,index) &#123; fn(index,item); &#125;); &#125; else &#123; // 不是数组就是对象 for (key in obj) &#123; fn(key,obj[key]); &#125; &#125;&#125;var arr = [1,2,3];//注意，这里参数的顺序换了，为了和对象的遍历格式一致forEach(arr,function(index,item) &#123; console.log(index,item); &#125;);var obj = &#123;x:100,y:200&#125;;forEach(obj,function(key,value) &#123; console.log(key,value);&#125;); 知识点： 日期 Math 数组API 对象API日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date();dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月 （0 - 11）dt.getDate(); //日 （0 - 31）dt.getHours(); //小时 （0 - 23）dt.getMinutes(); //分钟 （0 - 59）dt.getSeconds(); //秒 （0 - 59） Math 获取随机数 Math.random()数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否有至少一个元素符合条件 sort 排序 map 对元素重新组装，生成新数组 filter 过滤符合条件的元素123456//forEachvar arr = [1,2,3];arr.forEach(function(item,index) &#123; //遍历数组的所有元素 console.log(index,item);&#125;); 123456789//everyvar arr = [1,2,3];var result = arr.every(function(item,index) &#123; //用来判断所有的数组元素，都满足一个条件 if (item &lt; 4) &#123; return true; &#125;&#125;);console.log(result); 123456789//somevar arr = [1,2,3];var result = arr.some(function(item,index) &#123; //用来判断所有的数组元素，只要有一个满足条件即可 if (item &lt; 2) &#123; return true; &#125;&#125;);console.log(result); 123456789//sortvar arr = [1,4,2,3,5,10,16,25];var arr2 = arr.sort(function(a,b) &#123; //从小到大排序 return a - b; //从大到小排序 //return b - a;&#125;);console.log(arr2); 1234567//mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index) &#123; //将元素重新组装，并返回 return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;);console.log(arr2); 123456789//filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index) &#123; //通过某一条件过滤数组 if (item &gt;= 2) &#123; return true; &#125;&#125;);console.log(arr2); 对象API123456789101112var obj = &#123; x: 100, y: 200, z: 300&#125;;var key;for (key in obj) &#123; //注意这里的hasOwnProperty,再讲原型链时候讲过了,判断该属性是对象自身的属性，以防是来源于__proto__的 if (obj.hasOwnProperty(key)) &#123; console.log(key,obj[key]); &#125;&#125; 回顾JS基础知识 变量类型和计算 原型和原型链 闭包和作用域 异步和单线程 其他（如日期、Math、各种常用API） 特点：表面看来并不能用于工作中开发代码 内置函数：Object Array Boolean String … 内置对象：Math JSON … 我们连在网页弹出一句hello world都不能实现 JS基础知识：ECMA 262标准 JS-Web-API：W3C标准 W3C标准中关于JS的规定有： DOM操作 BOM操作 事件绑定 ajax请求(包括http协议) 存储 页面弹框是window.alert(123),浏览器需要做： 定义一个window全局变量，对象类型 给它定义一个alert属性，属性值是一个函数 获取元素document.getElementById(id),浏览器需要： 定义一个document全局变量，对象类型 给它定义一个getElementById的属性，属性值是一个函数 但是W3C标准没有规定任何JS基础相关的东西 不管什么变量类型、原型、作用域和异步 只管定义用于浏览器中JS操作页面的API和全局变量 全面考虑，JS内置的全局函数和对象有哪些? 之前讲过的Object Array Boolean String Math JSON等 刚刚提到的 window document 接下来还要继续讲到的所有未定义的全局变量，如navigator.userAgent 常说的JS（浏览器执行的JS）包含两个部分： JS基础知识（ECMA262标准） JS-Web-API（W3C标准） JS-Web-APIDOM操作题目 DOM是哪种基本的数据结构？ 树 DOM操作的常用API有哪些？ 获取DOM节点，以及节点的property和Attribute 获取父节点，获取子节点 新增节点，删除节点 DOM节点的attr和property有何区别 property只是一个JS对象的属性的修改 Attribute是对html标签属性的修改知识点 DOM本质 DOM节点操作 浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型而已。 DOM结构操作 DOM节点操作 获取DOM节点 123456var div1 = document.getElementById('div1'); //元素var divList = document.getElementsByTagName('div'); //集合console.log(divList.length);console.log(divList[0]);var containerList = document.getElementsByClassName('.container'); //集合var pList = document.querySelectorAll('p'); //集合 property 123456789var pList = document.querySelectorAll('p');var p = pList[0];console.log(p.style.width); //获取样式p.style.width = '100px'; //修改样式console.log(p.className); //获取classp.className = 'p1'; //修改class// 获取nodeName 和 nodeTypeconsole.log(p.nodeName);console.log(p.nodeType); Attribute 123456var pList = document.querySelectorAll('p');var p = pList[0];p.getAttribute('data-name');p.setAttribute('data-name','imooc');p.getAttribute('style');p.setAttribute('style','font-size:30px;'); DOM结构操作 新增节点 12345678var div1 = document.getElementById('div1');//添加新节点var p1 = document.createElement('p');p1.innerHTML = 'this is p1';div1.appendChild(p1); //添加新创建的元素//移动已有节点var p2 = document.getElementById('p2');div1.appendChild(p2); 获取父节点 12var div1 = document.getElementById('div1');var parent = div1.parentElement; 获取子节点 1var child = div1.childNodes; 删除节点 1div1.removeChild(child[0]); BOM操作题目 如何检测浏览器类型 123var ua = navigator.userAgent;var isChrome = ua.indexOf('Chrome');console.log(isChrome); 拆解url的各部分 123456// locationconsole.log(location.href);console.log(location.protocol); // 'http:' 'https:'console.log(location.pathname); // '/learn/199'console.log(location.search);console.log(location.hash); 知识点 navigator 1234//navigatorvar ua = navigator.userAgent;var isChrome = ua.indexOf('Chrome');console.log(isChrome); screen 123//screenconsole.log(screen.width);console.log(screen.height); location 123456// locationconsole.log(location.href);console.log(location.protocol); // 'http:' 'https:'console.log(location.pathname); // '/learn/199'console.log(location.search);console.log(location.hash); history 12history.back();history.forward(); 事件题目 编写一个通用的事件监听函数 1234567891011121314151617function bindEvent(elem,type,selector,fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type,function(e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target,e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125; 描述事件冒泡流程 DOM树形结构 事件冒泡 阻止冒泡 冒泡的应用 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 使用代理 知道代理的两个优点 知识点 通用事件绑定 123456789101112var btn = document.getElementById('btn1');btn.addEventListener('click',function(event) &#123; console.log('clicked');&#125;);function bindEvent(elem,type,fn) &#123; elem.addEventListener(type,fn);&#125;var a = document.getElementById('link1');bindEvent(a,'click',function(e) &#123; e.preventDefault(); //阻止默认行为 alert('clicked');&#125;); 事件冒泡 123456789101112131415161718192021222324252627//html部分&lt;body&gt; &lt;div class='div1'&gt; &lt;p id='p1'&gt;激活&lt;/p&gt; &lt;p id='p2'&gt;取消&lt;/p&gt; &lt;p id='p3'&gt;取消&lt;/p&gt; &lt;p id='p4'&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id='div2'&gt; &lt;p id='p5'&gt;取消&lt;/p&gt; &lt;p id='p5'&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;//js部分var p1 = document.getElementById('p1');var div1 = document.getElementsByClassName('div1')[0];var div2 = document.getElementById('div2');bindEvent(p1,'click',function(e) &#123; e.stopPropagation(); alert('激活');&#125;);bindEvent(div1,'click',function(e) &#123; alert('取消'); &#125;);bindEvent(div2,'click',function(e) &#123; alert('取消'); &#125;); 代理 12345678910111213141516//html代码&lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;!--会随时新增更多a标签--&gt;&lt;/div&gt;//js部分var div1 = document.getElementById('div1');div1.addEventListener('click',function(e) &#123; var target = e.target; if (target.nodeName === 'A') &#123; alert(target.innerHTML); &#125;&#125;); 完善通用绑定事件的函数123456789101112131415161718192021222324252627function bindEvent(elem,type,selector,fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type,function(e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target,e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125;//使用代理var div1 = document.getElementById('div1');bindEvent(div1,'click','a',function(e) &#123; console.log(this.innerHTML);&#125;);//不使用代理var a = document.getElementById('a1');bindEvent(a,'click',function(e) &#123; console.log(a.innerHTML);&#125;); 代理的好处 代码简洁 减少浏览器内存占用 Ajax题目 手动编写一个ajax，不依赖第三方库 12345678910var xhr = new XMLHttpRequest();xhr.open("GET","/api",false);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;&#125;;xhr.send(null); 跨域的几种实现方式JSONP服务器端设置http header知识点 XMLHttpRequest 状态码说明 跨域readyState 0 -(未初始化)还没有调用send()方法 1 -(载入)已调用send()方法，正在发送请求 2 -(载入完成)send()方法执行完成，已经接收到全部响应内容 3 -(交互)正在解析响应内容 4 -(完成)响应内容解析完成，可以在客户端调用了status 2xx - 表示成功处理请求。如200 3xx - 需要重定向，浏览器直接跳转 4xx - 客户端请求错误，如404 5xx - 服务器端错误 跨域 什么是跨域浏览器有同源策略，不允许ajax访问其他域接口跨域条件：协议、域名、端口，有一个不同就算跨域 JSONP 服务器端设置http header可以跨域的三个标签 但是有三个标签允许跨域加载资源 &lt;img src=xxx&gt; &lt;link href=xxxx&gt; &lt;script src=xxx&gt;&lt;/script&gt;三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN,CDN也可以是其他域 &lt;script&gt;可以用于JSONP跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许即可获取，那是浏览器同源策略出现漏洞JSONP实现原理 加载http://coding.m.imooc.com/classindex.html 不一定服务器端真正有一个classindex.html文件 服务端可以根据请求，动态生成一个文件，返回 同理于&lt;script src=&quot;http://coding.m.imooc.com/api.js&quot;&gt;&lt;/script&gt; 例如你的网站要跨域访问慕课网的一个接口 慕课给你一个地址http://coding.m.imooc.com/api.js 返回内容格式如callback({x:100,y:200})(可动态生成)12345678&lt;script&gt;window.callback = function(data) &#123; //这是我们跨域得到信息 console.log(data);&#125;;&lt;/script&gt;&lt;script src="http://coding.m.imooc.com/api.js"&gt;&lt;/script&gt;&lt;!--以上返回callback(&#123;x:100,y:200&#125;) --&gt; 服务器端设置http header 另外一个解决跨域的简洁方法，需要服务器端来做 但是作为交互方，我们必须知道这个方法 是将来解决跨域问题的一个趋势1234567//注意：不同后端语言的写法可能不一样//第二个参数填写允许跨域的域名称，不建议直接写"*"response.setHeader("Access-Control-Allow-Origin","http://a.com,http://b.com");response.setHeader("Access-Control-Allow-Header","X-Requested-With");response.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");//接收跨域的cookieresponse.setHeader("Access-Control-Allow-Credentials","true"); 存储题目 请描述cookie，sessionStorage和localStorage的区别？ 容量 是否会携带到ajax中 API易用性 知识点 本身用于客户端和服务器端通信 但是它有本地存储的功能，于是就被”借用” 使用document.cookie = …获取和修改即可 cookie用于存储的缺点 存储量太小，只有4KB 所有的http请求都带着，会影响获取资源的效率 API简单，需要封装才能用document.cookie = … locationStorage和sessionStorage HTML5专门为存储而设计，最大容量5M API简单易用 localStorage.setItem(key,value); localStorage.getItem(key); 坑： iOS safari隐藏模式下 localStorage.getItem会报错 建议统一使用try-catch封装 开发环境 面试官想通过开发环境了解面试者的经验 开发环境，最能体现工作产出的效率 会以聊天的形式为主，而不是出具体的问题 关于开发环境 IDE(写代码的效率) git(代码版本管理，多人协作开发) JS模块化 打包工具 上线回滚的流程 IDE webstorm sublime vscode atom 插件 Git 正式项目都需要代码版本管理 大型项目需要多人协作开发 Git和linux是一个作者 网络Git服务器如coding.net github.com 一般公司代码非开源，都有自己的Git服务器 搭建Git服务器无需你了解太多 Git的基本操作必须要熟练 常用Git命令 git add . (.把所有项目上传，也可以加文件名) git checkout xxx （改错了，想还原回去） git commit -m “xxx” （git commit把项目弄到本地 -m 加备注） git push origin master （提交给远程仓库） git pull orgin master （别人把你提交的pull下来） git branch （多人协作 切换到当前分支） git checked -b xxx/git checkout xxx （git checked -b新建分支/git checkout 切换到已有分支） git merge xxx 模块化 不使用模块化的情况 使用模块化 AMD CommonJS 不使用模块化 util.js getFormatDate函数 a-util.js aGetFormatDate函数 使用getFormatDate a.js aGetFormatDate1234567891011121314//util.jsfunction getFormatDate(data,type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 格式 // ...&#125;//a-util.jsfunction aGetFormatDate(date) &#123; //要求返回 2017年6月15日 格式 return getFormatDate(date,2);&#125;//a.jsvar dt = new Date();console.log(aGetFormatDate(dt)); 12345&lt;script src="util.js"&gt;&lt;/script&gt;&lt;script src="a-util.js"&gt;&lt;/script&gt;&lt;script src="a.js"&gt;&lt;/script&gt;&lt;!-- 1.这些代码中的函数必须是全局变量，才能暴露给使用方。全局变量污染 --&gt;&lt;!-- 2.a.js知道要引用a-util.js,但是他知道还需要依赖于util.js吗？ --&gt; AMD require.js 全局define函数 全局require函数 依赖JS会自动、异步加载 使用require.js12345678910111213141516171819202122232425262728293031323334//util.jsdefine(function() &#123; return &#123; getFormatDate: function(data,type) &#123; if (type === 1) &#123; return '2017-06-15'; &#125; if (type === 2) &#123; return '2017年6月15日'; &#125; &#125; &#125;&#125;)；//a-util.jsdefine(['./util.js'],function(util) &#123; return &#123; aGetFormatDate: function(date) &#123; return util.getFormatDate(date,2); &#125; &#125;&#125;);//a.jsdefine(['./a-util.js'],function() &#123; return &#123; printDate: function(date) &#123; console.log(aUtil.aGetFormatDate(date)); &#125; &#125;&#125;);//main.jsrequire(['./a.js'],function(a) &#123; var date = new Date(); a.printDate(date);&#125;); CommonJS nodejs模块化规范，现在被大量用前端，原因： 前端开发依赖的插件和库，都可以从npm中获取 构建工具的高度自动化，使得使用npm的成本非常低 CommonJS不会异步加载JS，而是同步一次性记载出来123456789101112131415161718//util.jsmodule.exports = &#123; getFormatDate: function(data,type) &#123; if (type === 1) &#123; return '2017-06-15'; &#125; if (type === 2) &#123; return '2017年6月15日'； &#125; &#125;&#125;;//a-util.jsvar util = require('util.js');module.exports = &#123; aGetFormatDate: function() &#123; return util.getFormatDate(date,2); &#125;&#125; AMD和CommonJS的使用场景 需要异步加载JS，使用AMD 使用了npm之后建议使用CommonJS 上线和回滚知识点： 上线和回滚的基本流程 linux基本命令 上线回滚流程介绍 是非常重要的开发环节 各个公司的具体流程不同 由专门的工具后者系统完成，我们无需关心细节 如果你没有参与过，面试时也要说出要点 只讲要点，具体实现无法讲解 上线流程要点 将测试完成的代码提交到git版本库的master分支 将当前服务器的代码全部打包并记录版本号，备份 将master分支的代码提交覆盖到线上服务器，生成新版本号 回滚流程要点 将当前服务器的代码打包并记录版本号，备份 将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号 linux基本命令 服务器使用linux居多，server版，只有命令行 测试环境要匹配线上环境，因此也是linux 经常需要登录测试机来自己配置、获取数据 运行环境 浏览器就可以通过访问链接来得到页面的内容 通过绘制和渲染，显示出页面的最终的样子 整个过程中，我们需要考虑什么问题？ 知识点 页面加载过程 性能优化 安全性 页面加载题目 从输入url到得到html的详细过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求 浏览器得到返回内容 window.onload 和 DOMContentLoaded的区别 页面的全部资源加载完才会执行，包括图片、视频等 DOM渲染完即可执行，此时图片、视频还没有加载完 知识点 加载资源的形式 加载一个资源的过程 浏览器渲染页面的过程 加载资源的形式 输入url（或跳转页面）加载html 加载html中的静态资源 &lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt; 加载一个资源的过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求 浏览器得到返回内容 浏览器渲染页面的过程 根据HTML结构生成DOM Tree 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 window.onload和DOMContentLoaded123456window.addEventListener('load',function() &#123; //页面的全部资源加载完才会执行，包括图片、视频等&#125;);document.addEventListener('DOMContentLoaded',function() &#123; //DOM渲染完即可执行，此时图片、视频还可能没有加载完&#125;); 性能优化原则 多使用内存、缓存或者其他方法 减少CPU计算、较少网络 从哪里入手 加载页面和静态资源 页面渲染 加载资源优化 静态资源的压缩合并 静态资源缓存 使用CDN让资源加载更快 使用SSR后端渲染，数据直接输出到HTML中 渲染优化 CSS放前面，JS放后面 懒加载（图片懒加载、下拉加载更多） 减少DOM查询，对DOM查询做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作（如DOMContentLoaded） 缓存 通过了解名称控制缓存 &lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt; 只有内容改变的时候，链接名称才会改变 &lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt; 使用SSR后端渲染 现在Vue React提出了这样的概念 其实jsp php asp都属于后端渲染 懒加载12345&lt;img src="img1" src="preview.png" data-realsrc="abc.png"/&gt;&lt;script type="text/javascript"&gt; var img1 = document.getElementById('img1'); img1.src = img1.getAttribute('data-realsrc');&lt;/script&gt; 缓存DOM查询1234567891011//未缓存DOM查询var i;for (i = 0;i &lt; document.getElementsByTagName('p').length;i++) &#123; //todo&#125;//缓存了DOM查询var pList = document.getElementsByTagName('p');var i;for (i = 0;i &lt; pList.length;i++) &#123; //todo&#125; 合并DOM插入12345678910var listNode = document.getElementById('list');//要插入10个li标签var frag = document.createDocumentFragment();var x,li;for (x = 0;x &lt; 10;x++) &#123; li = document.createElement("li"); li.innerHTML = "List item " + x; frag.appendChild(li);&#125;listNode.appendChild(frag); 事件节流12345678910var textarea = document.getElementById('text');var timeoutId;textarea.addEventListener('keyup',function() &#123; if (timeoutId) &#123; clearTimeout(timeoutId); &#125; timeoutId = setTimeout(function() &#123; //触发change事件 &#125;,100);&#125;); 安全性 XSS跨站请求攻击 XSRF跨站请求伪造 XSS 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取cookie，发送自己的服务器 发布博客，有人查看博客内容 会把查看者的cookie发送到攻击者的服务器 如何预防 前端替换关键字，例如替换&lt;为&amp;lt;&gt;为&amp;gt; 后端替换 XSRF 你已登录一个购物网站，正在浏览商品 该网站付费接口是xxx.com/pay?id=100但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx.com/pay?id=100&gt; 你查看邮件的时候，就已经悄悄的付费购买了 解决方案 增加验证流程，如输入指纹、密码、短信验证码 技巧 简历 面试过程中… 简历 简洁明了，重点突出项目经历和解决方案 把个人博客放在简历中，并且定期维护更新博客 把个人的开源项目放在简历中，并维护开源项目 简历千万不要造假，要保持能力和经历上的真实性 面试过程中 如何看待加班？加班就像借钱，救急不救穷 千万不可挑战面试官，不要反考面试官 学会给面试官惊喜，但不要太多 遇到不会回答的问题，说出你知道的也可以 谈谈你的缺点—说一下你最近正在学什么就可以了]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2018%2F02%2F16%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我的世界会有一束光，而我永远都会在最初的地方等它。亦如最初的自己 相关知识点：ES6:笔记：ES6学习笔记资料：阮一峰ES6 node.js:官网下载安装。检查安装成功的命令： node -v(node版本查询) npm -v(npm版本查询)cnpm:淘宝镜像 webpack:待补充： window命令：cd 定位到目录，用法：cd + 路径dir 列出文件列表cls 清空命令提示符窗口内容cd.. 定位至上层目录待补充。 React:React基础知识、React：用于构建用户界面的 JavaScript 库特点： 声明式：React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。（以声明式编写UI，可以让你的代码更加可靠，且方便调试。） 组件化：创建好拥有各自状态的组件，再由组件构成更加复杂的界面。（无需再用模版代码，通过使用JavaScript编写的组件你可以更好地传递数据，将应用状态和DOM拆分开来。） React组件基础、一：初步配置React开发环境 npm项目初始化：npm init(创建一个初始化的package.json) 项目依赖包安装: react、react-dom、babelify、babel-preset-react、babel-preset-es2015 （babel-core、babel-loader、webpack、webpack-dev-server） eg：npm react –save 保存到生产依赖环境npm react --save --dev 保存到开发依赖环境 webpack 热加载配置 全局安装webpack webpack-dev-server 项目内安装webpack webpack-dev-server 实现打包 webpack –watch 监控项目热加载浏览器：localhost:8080/webpack-dev-server/index.html 二：虚拟DOM概念如何理解虚拟DOM? 组件 组件的return 函数里返回的HTML节点必须是一个 可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{}入口的定义： ReactDOM.render(,document.getElementById(‘’)); 三：React多组件嵌套 组件也可以通过参数的形式传递 组件的return函数里返回的HTML节点必须是一个 注意项目命名的规范与文件的结构化 补充：代码中的’./‘ 表示当前目录下;.gitignore文件名写错以至于将相关包上传，以后注意！ 四：JSX内置表达式 {window.username == ‘’ ? ‘默认用户名’ : ‘用户名:’ + username} input中disable={} 单引号去掉 {/注释/} HTML要显示可以进行Unicode转码。 eg:&nbsp; HTML要显示还可以通过&lt;div dangerouslySetinnerHTML={ {__html:html} }&gt;&lt;/div&gt; 注意此方法可能会存在XSS攻击 补充：.gitignore内容写错node_module，应该是node_modules注意注意！加s 五：生命周期生命周期中的函数类似于钩子：钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。 component instantiated （组件初始化） getDefaultProps (获取默认属性） getInitialState (获取初始化state) componenntWillMount (组件将要加载的函数）componentDidMount (组件加载完毕的函数) propschanged （属性的更改） componentWillUpdate (将要update) componentDidUpdate (update完成) componentdeleted （组件删除） componentWillUnmount （组件卸载的函数） 补充:出现的问题引入的包 ‘react’、’react-dom’注意小写，创建组件 extends React.Component 写对，未解决问题：React Developer Tools会自动检测React组件，不过在webpack-dev-server模式下，webpack会自动将React组件放入到iframe下，导致React组件检测失败，变通方法是webpack-dev-server配置在–inline模式下即可，但是未成功，解决方法：在webpack-dev-server配置中没有inline:true去开启inline模式，因为webpack-dev-server模块无法访问webpack的配置。因此，用户必须添加webpack-dev-server的客户端入口文件到webpack的配置中，webpack-dev-server简单使用 React属性与事件、一：State 属性 state对于模块属于 自身 属性 初始化：this.state = {username:”Parry”}; 初始化可以放置在构造函数constructor里 修改state:this.setState({username:’liuxilei’}); state的作用域只属于当前的类，不污染其他模块 补充：状态值会立即（自动）反映在虚拟dom上然后显示在dom上;ReactDOM.render(,document.getElementById(‘’));这里没有引号，state改变可以实时反应在页面上，不刷新 二：Props属性 props 对于模块属于 外来 属性 传递参数：&lt;BodyIndex username=&#39;liuxilei&#39;/&gt; 模块中接收参数：this.props.username 三：事件与数据的双向绑定事件的绑定：注意es6的语法 可以在构造函数里绑定this:this.forceUpdateHandler = this.forceUpdateHandler.bind(this);.或者调用时绑定：onClick = {this.changeUserInfo.bind(this,50)}子页面向父页面传递参数的方法 在子页面中通过调用父页面传递过来的事件props进行组件间的参数传递 好好理解这里的onChange事件，为什么不用onBlur补充：this的指向：类的方法内部如果含有this，它将默认指向类的实例。MDN 四：可复用组件，真正让React开发快速、高效的地方Prop验证 https://doc.react-china.org/docs/typechecking-with-proptypes.html 注意: React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替。！！！！默认Prop值 const defaultProps = {text:’Hello world’}; 使用方法：BodyIndex.defaultProps = defaultProps;传递所有参数的快捷方式 &lt;Component{...this.props} more={&#39;values&#39;}/&gt; 五：组件的Refs操作DOM的两种方法 原始获取方法：var myDiv = document.getElementById(&#39;myDiv&#39;);React.findDOMNode(myDiv).style.color = &#39;red&#39;; （推荐使用）方法二的定义：&lt;input ref=&#39;myInput&#39; /&gt; 方法二的获取：this.refs.myInput Refs是访问到组件内部DOM节点唯一可靠的方法 Refs会自动销毁对子组件的引用 不要在render或render之前对Refs进行调用 不要滥用Refs 六：独立组件间共享Mixins 不同的组件之间共用功能、共享代码 和页面具有类似的生命周期 ES6下的使用要安装react-mixins]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习总结]]></title>
    <url>%2F2018%2F02%2F15%2FES6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[爱自己是终生浪漫的开始。 ES6学习总结第一部分：let、const命令作用域部分：在es6之前，es5有两个作用域:全局作用域和函数作用域1234567function test() &#123; for (var i = 1;i &lt; 3;i++) &#123; console.log(i); &#125; console.log(i);&#125;test(); //输出结果1 2 3 1234567function test() &#123; for (let i = 1;i &lt; 3;i++) &#123; console.log(i); &#125; console.log(i);&#125;test(); //报错:ReferenceError: i is not defined es6的块级作用域 es6中一段代码是用{}包起来的，这个大括号里面就是一个块级作用域，在这个作用域里面声明的变量在这个外面就不存在了，可以理解成这个变量的生命周期结束了;es6中强制开启了严格模式, es5中”use strict”;来开启严格模式。 let、const部分：let 声明变量不能再次声明12345function test() &#123; let a = 1; let a = 2;&#125;test();//报错:Error:Duplicate declaration(重复声明) const声明的常量是不能修改的123456function test() &#123; const PI = 3.1415926; PI = 8; console.log(PI);&#125;test();//报错：&quot;PI&quot; is read-only(PI是一个只读属性) const声明时必须赋值12345function test() &#123; const PI; PI = 3.1415926;&#125;//报错:Error:Unexpected token(代码不完整) 补充：const声明的常量是不能修改的，这句话不严谨解释：123456789function test() &#123; const PI = 3.1415926; const k = &#123; a: 1 &#125; k.b = 3; console.log(PI,k);&#125;test(); const声明的k对象是引用类型，返回值是对象存储内存中的指针，声明的k是指向对象中存储的指针 ，这个指针是不变的，但是对象本身是可变的。 第二部分：解构赋值什么是解构赋值：本质就是一种赋值，赋值操作符左边一种结构，右边一种结构，然后一一对应。解构赋值的分类 数组解构赋值 对象解构赋值 字符串解构赋值 布尔值解构赋值 函数参数解构赋值 数值解构赋值 数组解构赋值（左右都是数组）、对象解构赋值（左右都是对象）、字符串解构赋值（左边是数组，右边是字符串）、布尔值解构赋值（对象解构赋值中的一种）、函数参数解构赋值（数组解构赋值在函数参数这里的应用）、数值解构赋值（对象解构赋值中的一种） 1234//数组解构赋值（常见）let a,b,rest;[a,b] = [1,2];console.log(a,b);//1，2 123let a,b,rest;[a,b,...rest] = [1,2,3,4,5,6];console.log(a,b,rest); //1，2，[3,4,5,6] 1234//对象解构赋值（常见）let a,b;(&#123;a,b&#125; = &#123;a: 1,b: 2&#125;) //注意这里的括号console.log(a,b); //1，2 数组解构赋值、对象解构赋值使用的基本方法、默认值和应用场景 1234//默认值let a,b,c,rest;[a,b,c = 3] = [1,2];console.log(a,b,c); //1，2，3 123let a,b,c,rest;[a,b,c] = [1,2];console.log(a,b,c);//1，2，undefined (默认值的设定就是为了放置这种情况) 数组解构赋值的应用场景12345//变量的交换let a = 1;let b = 2;[a,b] = [b,a];console.log(a,b); //2，1 1234567//接收函数返回值 function f() &#123; return [1,2];&#125;let a,b;[a,b] = f();console.log(a,b); //1，2 123456function f() &#123; return [1,2,3,4,5];&#125;let a,b;[a,,,b] = f();console.log(a,b); //1，4 123456function f() &#123; return [1,2,3,4,5];&#125;let a,b;[a,,...b] = f();console.log(a,b); /1，[3,4,5] 1234567//对象解构赋值基本使用方法let o = &#123;p: 42,q: true&#125;let &#123;p,q&#125; = o;console.log(p,q); //42，true//默认值let &#123;a = 10,b = 5&#125; = &#123;a: 3&#125;;console.log(a,b); //3，5 对象解构赋值应用场景12345678910//模拟服务端给前端的JSON对象 let metaData = &#123; &apos;title&apos;: &apos;abc&apos;, &apos;test&apos; : [&#123; title: &apos;test&apos;, desc: &apos;description&apos; &#125;]&#125;let &#123;title: esTitle,test: [&#123;title: cnTitle&#125;]&#125; = metaData;console.log(esTitle,cnTitle); 第三部分：正则扩展正则新增特性 构造函数的变化 正则方法的扩展 u修饰符 y修饰符 s修饰符 构造函数的变化 1234567//es5创建正则的方式let regex = new RegExp(&apos;xyz&apos;,&apos;i&apos;);let regex2 = new RegExp(/xyz/i);console.log(regex.test(&apos;xyz123&apos;),regex2.test(&apos;xyz123&apos;));//true true//es6扩展的方式let regex3 = new RegExp(&apos;/xyz/ig&apos;,&apos;i&apos;); console.log(regex3.flags); //i y修饰符12345678//y也是全局搜索let s = &apos;bbb_bb_b&apos;;let a1 = /b+/g;let a2 = /b+/y;console.log(&apos;one&apos;,a1.exec(s),a2.exec(s)); //one [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;] [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;]console.log(&apos;two&apos;,a1.exec(s),a2.exec(s)); //two [&quot;bb&quot;, index: 4, input: &quot;bbb_bb_b&quot;] null//sticky判断是否带y修饰符console.log(a1.sticky,a2.sticky); //false true u修饰符1234567console.log(&apos;u-1&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); //u-1 trueconsole.log(&apos;u-2&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); //u-2 falseconsole.log(/\u&#123;61&#125;/.test(&apos;a&apos;));console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;));console.log(`\u&#123;20BB7&#125;`); //待补充… 第四部分：字符串扩展字符串新增特性 Unicode表示法 遍历接口 模板字符串 新增方法（10种） Unicode表示方法1234console.log(&apos;a&apos;,`\u0061`); //a aconsole.log(&apos;s&apos;,`\u20BB7`); //乱码console.log(&apos;s&apos;,`\u&#123;20BB7&#125;`); 12345678910111213let s = &apos;?&apos;; console.log(&apos;length&apos;,s.length);console.log(&apos;0&apos;,s.charAt(0));console.log(&apos;1&apos;,s.charAt(1));console.log(&apos;at0&apos;,s.charCodeAt(0));console.log(&apos;at1&apos;,s.charCodeAt(1));let s1 = &apos;?a&apos;;console.log(&apos;length&apos;,s1.length);console.log(&apos;code0&apos;,s1.codePointAt(0));console.log(&apos;code0&apos;,s1.codePointAt(0).toString(16));console.log(&apos;code1&apos;,s1.codePointAt(1));console.log(&apos;code2&apos;,s1.codePointAt(2)); 123//理解怎么用就okconsole.log(String.fromCharCode(&apos;0x20bb7&apos;));console.log(String.fromCodePoint(&apos;0x20bb7&apos;)); 字符串遍历器接口12345678910111213141516let str = &apos;\u&#123;20bb7&#125;abc&apos;;for (let i = 0;i &lt; str.length;i++) &#123; console.log(&apos;es5&apos;,str[i]);&#125;//es5 乱码//es5 乱码//es5 a//es5 b//es5 cfor (let code of str) &#123; console.log(&apos;es6&apos;,code);&#125;//es6 吉//es6 a//es6 b//es6 c 12345//判断字符串是否包含某个字符串，或者以某个字符串开始或结束的let str = &apos;string&apos;;console.log(&apos;includes&apos;,str.includes(&apos;c&apos;)); //includes falseconsole.log(&apos;start&apos;,str.startsWith(&apos;str&apos;)); //start trueconsole.log(&apos;end&apos;,str.endsWith(&apos;ng&apos;)); //end true 123//把某个字符串重复两遍let str = &apos;abc&apos;;console.log(str.repeat(2)); //abcabc 模板字符串（很重要）1234let name = &apos;list&apos;;let info = &apos;hello world&apos;;let m = `i am $&#123;name&#125;,$&#123;info&#125;`; console.log(m); //i am list,hello world 1234//es7草案//补白console.log(&apos;1&apos;.padStart(2,&apos;0&apos;)); //01console.log(&apos;1&apos;.padEnd(2,&apos;0&apos;)); //10 1234567891011//标签模板(很重要)//作用：过滤html字符串，防止xss攻击;处理多语言转换，通过不同的return返回不同的语言let user = &#123; name: &apos;list&apos;, info: &apos;hello world&apos;&#125;;console.log(abc`i am $&#123;user.name&#125;,$&#123;user.info&#125;`); function abc(s,v1,v2) &#123; console.log(s,v1,v2); return s + v1 + v2;&#125; 12345//用的不多，了解即可 rawconsole.log(String.raw`Hi\n$&#123;1+2&#125;`); //Hi\n3console.log(`Hi\n$&#123;1+2&#125;`);\\Hi\\3 第五部分：数值扩展数值处理新增特性 新增方法 方法调整 12console.log(0b111110111); //503 (二进制)console.log(0o767); //503 (八进制) 12345//使用频率不高，了解即可console.log(&apos;15&apos;,Number.isFinite(15)); //15 trueconsole.log(&apos;NaN&apos;,Number.isFinite(NaN)); //NaN falseconsole.log(&apos;1/0&apos;,Number.isFinite(&apos;true&apos;/0)); //1/0 falseconsole.log(&apos;NaN&apos;,Number.isNaN(NaN)); NaN true 12345//判断这个数是不是一个整数console.log(&apos;25&apos;,Number.isInteger(25)); //25 trueconsole.log(&apos;25.0&apos;,Number.isInteger(25.0)); //25.0 trueconsole.log(&apos;25.1&apos;,Number.isInteger(25.1)); //25.1 falseconsole.log(&apos;25字符串&apos;,Number.isInteger(&apos;25&apos;)); //&apos;25&apos; false 123console.log(&apos;最大上限:&apos;,Number.MAX_SAFE_INTEGER,&apos;最小下限:&apos;,Number.MIN_SAFE_INTEGER);console.log(&apos;10&apos;,Number.isSafeInteger(10)); //10 trueconsole.log(&apos;a&apos;,Number.isSafeInteger(&apos;a&apos;)); //a false 123//取小数的整数部分(常用)console.log(&apos;4.1&apos;,Math.trunc(4.1)); // 4.1 4console.log(&apos;4.9&apos;,Math.trunc(4.9)); //4.9 4 123456//判断是否为正数、负数、0 返回值分别为1、-1、0console.log(&apos;-5&apos;,Math.sign(-5)); //-5 -1console.log(&apos;0&apos;,Math.sign(0)); //0 0console.log(&apos;5&apos;,Math.sign(5)); //5 1console.log(&apos;50&apos;,Math.sign(&apos;50&apos;));//自动把&apos;50&apos;字符串转换为数值再进行判断 //&apos;50&apos; 1console.log(&apos;foo&apos;,Math.sign(&apos;foo&apos;)); //foo NaN 123//立方根console.log(&apos;-1&apos;,Math.cbrt(-1)); //-1 -1console.log(&apos;8&apos;,Math.cbrt(8)); //8 2 第六部分：数组扩展数组新增特性 Array.from Array.of copyWithin find\findIndex fill entries\keys\values includes 123456//把一组数据转成数组let arr = Array.of(3,4,7,9,11);console.log(&apos;arr=&apos;,arr); //arr= [3,4,7,9,11]let empty = Array.of();console.log(&apos;empty&apos;,empty); //empty [] 1234567891011//Array.from:把一些伪数组、集合转换为真正的数组let p = document.querySelectorAll(&apos;p&apos;);let pArr = Array.from(p);console.log(pArr);pArr.forEach(function(item) &#123; console.log(item.textContent);&#125;)//类似与map的作用console.log(Array.from([1,3,5],function(item) &#123; return item * 2;&#125;)); 123//填充数组console.log(&apos;fill-7&apos;,[1,&apos;a&apos;,undefined].fill(7)); //fill-7 [7,7,7]console.log(&apos;fill,pos&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,3)); //fill,pos [&apos;a&apos;,7,7] 1234567891011121314151617181920//遍历新方法for (let index of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].keys()) &#123; console.log(&apos;keys&apos;,index);&#125;//keys 0//keys 1//keys 2//要babel-polyfill，不然不支持for (let value of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].values()) &#123; console.log(&apos;values&apos;,value);&#125;//values 1//values c//values ksfor (let [index,value] of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].entries()) &#123; console.log(&apos;values&apos;,index,value);&#125;//values 0 1//values 1 c//values 2 ks 12//在当前数组内部把指定位置的成员复制到其他位置（使用场景不多，使用频率不高）console.log([1,2,3,4,5].copyWithin(0,3,4)); //[4,2,3,4,5] 1234567//查找 功能更强console.log([1,2,3,4,5,6].find(function(item) &#123; return item &gt; 3;&#125;)); //4（找到第一个满足条件的数组成员，不继续往后查找）console.log([1,2,3,4,5,6].findIndex(function(item) &#123; return item &gt; 3;&#125;)); //3 （找到第一个满足条件的数组成员，不继续往后查找，返回这个成员的索引位置） 123//和find差不多的作用，不过实用效果更好,可以判断NaNconsole.log(&apos;number&apos;,[1,2,NaN].includes(1)); //number trueconsole.log(&apos;number&apos;,[1,2,NaN].includes(NaN)); //number true 第七部分：函数扩展函数新增特性 参数默认值 rest参数 扩展运算符 箭头函数 this绑定 尾调用 参数默认值123456//默认值后面不能再有没有默认值的变量!!!function test(x,y = &apos;world&apos;) &#123; console.log(&apos;默认值&apos;,x,y);&#125;test(&apos;hello&apos;); //hello worldtest(&apos;hello&apos;,&apos;kill&apos;); //hello kill 与作用域相关的1234567891011let x = &apos;test&apos;;function test2(x,y = x) &#123; console.log(&apos;作用域&apos;,x,y);&#125;test2(&apos;kill&apos;); //作用域 kill killtest2(); //作用域 undefined undefinedfunction test3(c,y = x) &#123; console.log(&apos;作用域&apos;,c,y);&#125;test3(&apos;kill&apos;); //作用域 kill test rest参数1234567891011function test4(...arg) &#123; for (let v of arg) &#123; console.log(&apos;rest&apos;,v); &#125;&#125;test4(1,2,3,4,&apos;a&apos;); //rest 1//rest 2//rest 3//rest 4//rest a 扩展运算符12console.log(...[1,2,4]); //1 2 4console.log(&apos;a&apos;,...[1,2,4]); //a 1 2 4 箭头函数12345//箭头函数注意this绑定let arrow = v =&gt; v*2;let arrow2 = () =&gt; 5;console.log(&apos;arrow&apos;,arrow(3)); //arrow 6console.log(&apos;arrow2&apos;,arrow2()); //arrow2 5 尾调用：好处（提升性能）123456789//存在于函数式编程//函数的最后一句话是不是一个函数function tail(x) &#123; console.log(&apos;tail&apos;,x);&#125;function fx(x) &#123; return tail(x);&#125;fx(123); //tail 123 第八部分：对象扩展函数新增特性 简洁表示法 属性表达式 扩展运算符 Object新增方法 简洁表示法123456789101112131415161718192021222324let o = 1;let k = 2;let es5 = &#123; o: o, k: k&#125;;let es6 = &#123; o, k&#125;console.log(es5,es6); //&#123;k:2,o:1&#125; &#123;k:2,o:1&#125;let es5_method = &#123; hello: function() &#123; console.log(&apos;hello&apos;); &#125;&#125;;let es6_method = &#123; hello() &#123; console.log(&apos;hello&apos;); &#125;&#125;;es5_method.hello(); //helloes6_method.hello(); //hello 属性表达式123456789let a = &apos;b&apos;;let es5_obj = &#123; a: &apos;c&apos;, b: &apos;c&apos;&#125;;let es6_obj = &#123; [a]: &apos;c&apos;&#125;;console.log(es5_obj,es6_obj); &#123;a:&apos;c&apos;,b:&apos;c&apos;&#125; &#123;b:&apos;c&apos;&#125; 12345678910111213//新增API//is 判断两个值是否相等console.log(&apos;字符串&apos;,Object.is(&apos;abc&apos;,&apos;abc&apos;),&apos;abc&apos; === &apos;abc&apos;); //true trueconsole.log(&apos;数组&apos;,Object.is([],[]),[] === []); //false false 注意数组是引用类型//浅拷贝（只拷贝自身的属性，继承的不拷贝、还有不可枚举的属性也不拷贝）console.log(&apos;拷贝&apos;,Object.assign(&#123;a: &apos;a&apos;&#125;,&#123;b: &apos;b&apos;&#125;)); //&#123;a:&apos;a&apos;,b:&apos;b&apos;&#125;let test = &#123;k: 123,o: 456&#125;;for (let [key,value] of Object.entries(test)) &#123; console.log([key,value]);&#125;// [&apos;k&apos;,123]// [&apos;o&apos;,456] 12345678//babel不支持，实用性也用不到//扩展运算符let &#123;a,b...c&#125; = &#123;a: &apos;test&apos;,b: &apos;kill&apos;,c: &apos;ddd&apos;,d: &apos;ccc&apos;&#125;;//c的值如下：//c = &#123;// c: &apos;ddd&apos;,// d: &apos;ccc&apos;//&#125; 第九部分：SymbolSymbol的概念这种数据类型提供一个独一无二的值 Symbol的作用123456789//声明let a1 = Symbol();let a2 = Symbol();console.log(a1 === a2); //false//另一种声明方式//这里a3是一个key值，用Symbol.for声明这个独一无二的值时会先去全局注册，如果注册过，返回那个值，如果没注册，则调用Symbol生成一个独一无二的值。let a3 = Symbol.for(&apos;a3&apos;);let a4 = Symbol.for(&apos;a3&apos;);console.log(a3 === a4); //true 应用场景：12345678910111213141516171819202122232425let a1 = Symbol.for(&apos;abc&apos;);let obj = &#123; [a1]: &apos;123&apos;, &apos;abc&apos;: 345, &apos;c&apos;: 456&#125;;console.log(&apos;obj&apos;,obj); //obj &#123;Symbol(abc):&apos;123&apos;,abc:345,c:456&#125;//通过Symbol定义的属性，for in 和let of取不到该属性for (let [key,value] of Object.entries(obj)) &#123; console.log(&apos;let of&apos;,key,value);&#125;// let of abc 345// let of c 456API:getOwnPropertySymbols获取到的是一个数组（只拿到Symbol类型的属性）Object.getOwnPropertySymbols(obj).forEach(function(item) &#123; console.log(obj[item]);&#125;);// 123//取到所有属性，包括Symbol类型Reflect.ownKeys(obj).forEach(function(item) &#123; console.log(&apos;ownKeys&apos;,item,obj[item]);&#125;);//ownKeys abc 345//ownKeys c 456//ownKeys Symbol(abc) 123 第十部分：数据结构 Set的用法 WeakSet的用法 Map的用法 WeakMap的用法 Set的定义：1234let list = new Set();list.add(5);list.add(7);console.log(&apos;size&apos;,list.size); //size 2 123let arr = [1,2,3,4,5];let list = new Set(arr);console.log(&apos;size&apos;,list.size); //size 5 1234567891011//Set数据类型中元素必须唯一的let list = new Set();list.add(1);list.add(2);list.add(1);console.log(&apos;list&apos;,list); //list Set&#123;1，2&#125;//去重let arr = [1,2,3,1,&apos;2&apos;];let list2 = new Set(arr);console.log(&apos;unque&apos;,list2); //unque Set&#123;1，2，3,&apos;2&apos;&#125; 1234567//Set的添加、删除、清空let arr = [&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;];let list = new Set(arr);console.log(&apos;has&apos;,list.has(&apos;add&apos;)); //has trueconsole.log(&apos;delete&apos;,list.delete(&apos;add&apos;),list); //delete true Set&#123;&quot;delete&quot;,&quot;clear&quot;,&quot;has&quot;&#125;list.clear();console.log(&apos;list&apos;,list); //list Set&#123;&#125; 1234567891011121314151617181920212223242526272829303132//Set的遍历let arr = [&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;];let list = new Set(arr);for (let key of list.keys()) &#123; console.log(&apos;keys&apos;,key);&#125;//keys add//keys delete//keys clear//keys hasfor (let value of list.values()) &#123; console.log(&apos;values&apos;,value);&#125;//values add//values delete//values clear//values hasfor (let [key,value] of list.entries()) &#123; console.log(&apos;entries&apos;,key,value);&#125;//entries add add//entries delete//entries clear//entries haslist.forEach(function(item) &#123; console.log(item);&#125;);//add//delete//clear//has WeakSet 123456//WeakSet中的元素只能是对象 对象都是弱引用，不会被垃圾回收机制检测//没有size属性,没有clear方法，不能遍历let weaklist = new WeakSet();let arg = &#123;&#125;;weaklist.add(arg);console.log(&apos;weakList&apos;,weaklist);//weakList WeakSet&#123;Object&#123;&#125;&#125; Map //Map的基本定义 var map = new Map(); let arr = [&apos;123&apos;]; map.set(arr,456); console.log(&apos;map&apos;,map,map.get(arr)); //map Map{[&apos;123&apos;] =&gt; 456} 456 //第二种定义方法 let map = new Map([[&apos;a&apos;,123],[&apos;b&apos;,456]]); console.log(&apos;map&apos;,map); //map Map{&quot;a&quot; =&gt; 123,&quot;b&quot; =&gt; 456} console.log(&apos;size&apos;,map.size); //size 2 console.log(&apos;delete&apos;,map.delete(&apos;a&apos;),map); //delete true Map{&quot;b&quot; =&gt; 456} console.log(&apos;clear&apos;,map.clear(),map); //clear undefined Map{} 遍历和Set一样WeakMap //接收的key值必须是对象，也没有size属性，没有clear方法，不能遍历 let weakmap = new WeakMap(); let o = {}; weakmap.set(o,123); console.log(weakmap); //WeakMap {…} =&gt; 123 console.log(weakmap.get(o)); //123]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载node.js基本操作-gulp安装]]></title>
    <url>%2F2018%2F01%2F03%2Fnode.js%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89gulp%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[阳光沥心头，仿佛自由人。 安装gulp时候遇到的问题，然后百度到一个详细的基本操作加window命令的博客，（gulp要全局安装，再本地安装。不然本地安装gulp -v 会报：不是内部或外部命令，也没有可运行的程序或批处理文件链接）简介：gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 在学习前，先谈谈大致使用gulp的步骤，给读者以初步的认识。首先当然是安装nodejs，通过nodejs的npm全局安装和项目安装gulp，其次在项目里安装所需要的gulp插件，然后新建gulp的配置文件gulpfile.js并写好配置信息（定义gulp任务），最后通过命令提示符运行gulp任务即可。安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务1、安装node js 1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs； 1.2、安装：打开nodejs官网，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。然后像安装QQ一样安装它就可以了（安装路径随意）。 2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）2.2、注：之后操作都是在windows系统下； 2.3、简单介绍gulp在使用过程中常用命令，打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）： node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。PS：未能出现版本号，请尝试注销电脑重试； npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器，那它有什么用呢？稍后解释； cd定位到目录，用法：cd + 路径 ； dir列出文件列表； cls清空命令提示符窗口内容。 3、npm介绍3.1、说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 3.2、使用npm安装插件：命令提示符执行npm install package [-g] [–save-dev]； 3.2.1、package：node插件名称。例：npm install gulp-less –save-dev 3.2.2、-g：全局安装。将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； 3.2.3、–save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； 3.2.4、-dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；一般保存在dependencies的像这些express/ejs/body-parser等等。 3.2.5、为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install –production只下载dependencies节点的包）。 3.3、使用npm卸载插件：npm uninstall package [-g] [–save-dev] PS：不要直接删除本地插件包 3.3.1、删除全部插件：npm uninstall gulp-less gulp-uglify gulp-concat ……???太麻烦 3.3.2、借助rimraf：npm install rimraf -g 用法：rimraf node_modules 3.4、使用npm更新插件：npm update package [-g] [–save-dev] 3.4.1、更新全部插件：npm update [–save-dev] 3.5、查看npm帮助：npm help 3.6、当前目录已安装插件：npm list PS：npm安装插件过程：从http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法往下看↓↓↓↓↓↓。 4、选装cnpm4.1、说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”； 4.2、官方网址：http://npm.taobao.org； 4.3、安装：命令提示符执行npm install cnpm -g –registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。 5、全局安装gulp5.1、说明：全局安装gulp目的是为了通过她执行gulp任务； 5.2、安装：命令提示符执行cnpm install gulp -g； 5.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。 6、新建package.json文件6.1、说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；6.2、它是这样一个json文件（注意：json文件内是不能写注释的，复制下列内容请删除注释）： 12345678910111213141516171819&#123; &quot;name&quot;: &quot;test&quot;, //项目名称（必须） &quot;version&quot;: &quot;1.0.0&quot;, //项目版本（必须） &quot;description&quot;: &quot;This is for study gulp project !&quot;, //项目描述（必须） &quot;homepage&quot;: &quot;&quot;, //项目主页 &quot;repository&quot;: &#123; //项目资源库 &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://git.oschina.net/xxxx&quot; &#125;, &quot;author&quot;: &#123; //项目作者信息 &quot;name&quot;: &quot;surging&quot;, &quot;email&quot;: &quot;surging2@qq.com&quot; &#125;, &quot;license&quot;: &quot;ISC&quot;, //项目许可协议 &quot;devDependencies&quot;: &#123; //项目依赖的插件 &quot;gulp&quot;: &quot;^3.8.11&quot;, &quot;gulp-less&quot;: &quot;^3.0.0&quot; &#125;&#125; 6.3、当然我们可以手动新建这个配置文件，但是作为一名有志青年，我们应该使用更为效率的方法：命令提示符执行cnpm init 6.4、查看package.json帮助文档，命令提示符执行cnpm help package.json特别注意：package.json是一个普通json文件，所以不能添加任何注释。参看 http://www.zhihu.com/question/23004511 7、本地安装gulp插件7.1、安装：定位目录命令后提示符执行cnpm install –save-dev； 7.2、本示例以gulp-less为例（编译less文件），命令提示符执行cnpm install gulp-less –save-dev；7.3、将会安装在node_modules的gulp-less目录下，该目录下有一个gulp-less的使用帮助文档README.md； 7.4、为了能正常使用，我们还得本地安装gulp：cnpm install gulp –save-dev；PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。 8、新建gulpfile.js文件（重要）8.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。 8.2、它大概是这样一个js文件（更多插件配置请查看这里）： 12345678910111213141516//导入工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), //本地安装gulp所用到的地方 less = require(&apos;gulp-less&apos;); //定义一个testLess任务（自定义任务名称）gulp.task(&apos;testLess&apos;, function () &#123; gulp.src(&apos;src/less/index.less&apos;) //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest(&apos;src/css&apos;)); //将会在src/css下生成index.css&#125;); gulp.task(&apos;default&apos;,[&apos;testLess&apos;, &apos;elseTask&apos;]); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务 //gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径 9、运行gulp9.1、说明：命令提示符执行gulp 任务名称； 9.2、编译less：命令提示符执行gulp testLess； 9.3、当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。 10、使用webstorm运行gulp任务10.1、说明：使用webstorm可视化运行gulp任务； 10.2、使用方法：将项目导入webstorm，右键gulpfile.js 选择”Show Gulp Tasks”打开Gulp窗口，若出现”No task found”，选择右键”Reload tasks”，双击运行即可。 11.原帖地址本文为转载。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON高程笔记]]></title>
    <url>%2F2017%2F12%2F21%2FJSON(%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0)%2F</url>
    <content type="text"><![CDATA[人生若只如初见，无关风月，只为真心。 JSON是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据。关于JSON，最重要的是要理解它是一种数据格式，不是一种编程语言。语法JSON的语法可以表示以下三种类型的值。简单值:使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持JavaScript中的特殊值undefined。对象:对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。数组:数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型—简单值、对象和数组。JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript中表示数据的某些语法相同，但它并不局限JavaScript的范畴。 简单值最简单的JSON数据形式就是简单值。例如，下面这个值是有效的JSON数据: 15 这是JSON表示数值5的方式。类似地，下面是JSON表示字符地方式: 1&quot;Hello world!&quot; JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号(单引号会导致语法错误)。布尔值和null也是有效的JSON形式。但是，在实际应用中，JSON更多地用来表示更复杂地数据结构，而简单值只是整个数据结构中的一部分。 对象JSON中的对象与JavaScript字面量稍微有一些不同。下面是一个JavaScript中的对象字面量: 1234var person = &#123; name:&quot;Nicholas&quot;, age:29&#125;; 这虽然是开发人员在JavaScript中创建对象字面量的标准方式，但JSON中的对象要求给属性加引号。实际上，在JavaScript中，前面的字面量完全可以写成下面这样: 1234var object = &#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29&#125; JSON表示上述对象的方式如下： 1234&#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29&#125; 与JavaScript的对象字面量相比，JSON对象有两个地方不一样。首先，没有声明变量(JSON中没有变量的概念。)其次，没有末尾的分号(因为这不是JavaScript语句，所以不需要分号)。再说一遍，对象的属性必须加双引号，这在JSON中是必须的。属性的值可以是简单值，也可以是复杂类型值，因此可以像下面这样在对象中嵌入对象: 12345678&#123; &quot;name&quot;:&quot;Nicholas&quot;, &quot;age&quot;:29, &quot;school&quot;: &#123; &quot;name&quot;:&quot;Merrimack College&quot;, &quot;location&quot;:&quot;North Andover,MA&quot; &#125;&#125; 这个例子在顶级对象中嵌入了学校(“school”)信息。虽然有两个”name”属性，但由于它们分别属于不同的对象，因此这样完全没有问题。不过，同一个对象中绝对不应该出现两个同名属性。与JavaScript不同，JSON中对象的属性名任何时候都必须加双引号。手工编写JSON时，忘了给对象属性名加双引号或者把双引号写成单引号都是常见的错误。 数组JSON中的第二种复杂数据类型是数组。JSON数组采用的就是JavaScript中的数组字面量形式。例如，下面是JavaScript中的数组字面量: 1var values = [25,&quot;hi&quot;,true]; 在JSON中，可以采用同样的语法表示同一个数组： 1[25,&quot;hi&quot;,true] 同样要注意，JSON数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。对象和数组通常是JSON数据格式的最外层形式(当然，这不是强制规定的)，利用它们能够创造出各种各样的数据结构。 解析与序列化JSON对象早期的JSON解析器基本上就是eval()函数。由于JavaScript语法的子集，因此eval()函数可以解析、解释并返回JavaScript对象和数组。ECMAScript5对解析JSON的行为进行规范，定义了全局对象JSON。使用eval()对JSON数据结构求值存在风险，因为可能会执行一些恶意代码。JSON对象有两个方法:stringify()和parse()。在最简单的情况下，这两个方法分别用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript值。例如 123456789var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C.Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book); 这个例子使用JSON.stringify()把一个JavaScript对象序列化为一个JSON字符串，然后将它保存在变量jsonText中。默认情况下，JSON.stringify()输出的JSON字符串不包含任何空格字符或缩进，因此保存在jsonText中的字符串如下所示： 1&#123;&quot;title&quot;:&quot;Professional&quot;,&quot;authors&quot;:[&quot;Nicholas C.Zakas&quot;],&quot;edition&quot;:3&#125; 在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined的任何属性也都会被跳过。结果中最终都是值为有效的JSON数据类型的实例属性。将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值。例如，使用下列代码就可以创建与book类似的对象: 1var bookCopy = JSON.parse(jsonText); 注意，虽然book与bookCopy具有相同的属性，但它们是两个独立的、没有任何关系的对象。如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误。 序列化选项实际上，JSON.stringify()除了要序列化的JavaScript对象外，还可以接受另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用这两个参数，可以更全面深入地控制JSON的序列化。1.过滤结果如果过滤器是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性。来看下面的例子。 123456789var book = &#123; &quot;title&quot;:&quot;Professional JavaScript&quot;, &quot;authors&quot;:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,[&quot;title&quot;,&quot;edition&quot;); JSON的第二个参数是一个数组，其中包含两个字符串:”title”和”edition”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符串中，就会包含这两个属性: 1&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3&#125; 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性(键)名和属性值。根据属性(键)名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。为了改变序列化对象的结果，函数返回的值就是相应键的值。不过要注意，如果函数返回了undefined，那么相应的属性会被忽略。还是看一个例子吧 1234567891011121314151617181920var book = &#123; title:&quot;Professional JavaScript&quot;, author:[ &quot;Nicholas C. Zakas&quot;, ], editor:3, year:2011&#125;;var jsonText = JSON.stringify(book,function(key,value) &#123; switch(key) &#123; case &quot;authors&quot;: return value.join(&quot;,&quot;); case &quot;year&quot;: return 5000; case &quot;edition&quot;: return undefined; default: return value; &#125;&#125;); 这里函数过滤器根据传入的键来决定结果。如果键为”authors”,就将数组连接为一个字符串;如果键为”year”,则将其值设置为5000；如果键为”edition”,通过返回undefined删除该属性。最后，一定要提供default项，此时返回传入的值，以便其他值都能正常出现在结果中。实际上，第一次调用这个函数过滤器，传入的键是一个空字符串，而值就是book对象。序列化后的JSON字符串如下所示： 1&#123;”title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000&#125; 2.字符串缩进JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每一个级别缩进的空格数。例如，要在每个级别缩进4个空格，可以这样写代码： 123456789var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011&#125;;var jsonText = JSON.stringify(book,null,4); 保存在jsonText中的字符串如下所示： 12345678&#123; “title&quot;:&quot;Professional JavaScript&quot;, &quot;authors&quot;:[ &quot;Nicholas C. Zakas&quot; ], &quot;edition&quot;:3, &quot;year&quot;:2011&#125; 不知道读者注意到没有，JSON.stringify()也在结果字符串中插入了换行符以提高可读性。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。(只缩进而不换行意义不大)最大缩进空格数为10，所有大于10的值都会自动转换为10。如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用做缩进字符(不再使用空格)。在使用字符串的情况下，可以将缩进字符设置为制表符，或者两个短划线之类的任意字符。 1var jsonText = JSON.stringify(book,null,&quot;--&quot;); 这样，jsonText中的字符串将变成如下所示： 12345678&#123;--&quot;title&quot;:&quot;Professional JavaScript&quot;,--&quot;authors&quot;:[----&quot;Nicholas C. Zakas&quot;--],--&quot;edition&quot;:3,--&quot;year&quot;:2011&#125; 3.toJSON()方法有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义toJSON()方法，返回其自身的JSON数据格式。原生Date对象有一个toJSON()方法，能够将JavaScript的Date对象自动转换成ISO 8601日期字符串(与在Date对象上调用toISOString()的结果完全一样)。可以为任何对象添加toJSON()方法，比如： 123456789101112var book = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, toJSON:function() &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book); 以上代码在book对象上定义了一个toJSON()方法，该方法返回图书的书名。与Date对象类似，这个对象也将被序列化为一个简单的字符串而非对象。可以让toJSON()方法返回任何值，它都能正常工作。比如。可以让这个方法返回undefined，此时如果包含它的对象嵌入在另一个对象中，会导致它的值变成null，而如果它是顶级对象，结果就是undefined。 toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要。假设把一个对象传入JSON.stringify(),序列化对象的顺序如下： 如果存在toJSON()方法而且能够通过它取得有效的值，则调用该方法。否则，返回对象本身。 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第1步返回的值。 对第2步返回的每个值进行相应的序列化。 如果提供了第三个参数，执行相应的格式化。 无论是考虑定义toJSON()方法，还是考虑使用函数过滤器，亦或需要同时使用两者，理解这个顺序都是至关重要的。解析选项JSON.parse()方法也可以接受另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别JSON.stringify()接收的过滤函数，这个函数被称为还原函数，但实际上这两个函数的签名是相同的–它们都接收两个参数，一个键和一个值，而且都需要返回一个值。如果还原函数返回undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将日期字符串转换为Date对象时，经常要用到还原函数。例如： 123456789101112131415161718var books = &#123; title:&quot;Professional JavaScript&quot;, authors:[ &quot;Nicholas C. Zakas&quot; ], edition:3, year:2011, releaseDate:new Date(2011,11,1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText,function(key,value)&#123; if (key == &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);console.log(bookCopy.releaseDate.getFullYear());]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery attr方法获取input的checked属性问题]]></title>
    <url>%2F2017%2F12%2F17%2Fjquery%20attr%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96input%E7%9A%84checked%E5%B1%9E%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[欲戴王冠必承其重；天道酬勤，功不唐捐。 问题：经常使用jQuery插件的attr方法获取checked属性值，获取的值的大小为未定义，此时可以用prop方法获取其真实值，下面介绍这两种方法的区别：1.通过prop方法获取checked属性，获取的checked返回值为boolean，选中为true,否则为flase123456&lt;input type=&quot;checkbox&quot; id=&quot;selectAll&quot; onclick=&quot;checkAll()&quot;&gt;全选 function checkAll() &#123; var checkedOfAll = $(&quot;#selectAll&quot;).prop(&quot;checked&quot;); console.log(checkedOfAll); $(&quot;input[name=&apos;procheck&apos;]&quot;).prop(&quot;checked&quot;, checkedOfAll); &#125; 2.如果使用attr方法获取时，如果当前input中初始化未定义checked属性，则不管当前是否选中，$(“#selectAll”).attr(“checked”)都会返回undefined；1&lt;input type=&quot;checkbox&quot; id=&quot;selectAll&quot; onclick=&quot;checkAll()&quot; &gt;全选 如果当前input中初始化已定义checked属性，则不管是否选中，$(“#selectAll”).attr(“checked”)都会返回checked. 123456&lt;input type=&quot;checkbox&quot; id=&quot;selectAll&quot; onclick=&quot;checkAll()&quot; checked&gt;全选 function checkAll() &#123; var checkedOfAll = $(&quot;#selectAll&quot;).attr(&quot;checked&quot;); console.log(checkedOfAll); $(&quot;input[name=&apos;procheck&apos;]&quot;).attr(&quot;checked&quot;, checkedOfAll); &#125; 总结，如果使用jquery,应使用prop方法来获取和设置checked属性，不应使用attr.转载脚本之家]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQuery-事件和动画]]></title>
    <url>%2F2017%2F12%2F14%2F%E9%94%8B%E5%88%A9%E7%9A%84jQuery-%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[我想陪你去所有地方，感受世间所有的苍凉，也许有天你将我遗忘，我还有回忆可想。 jQuery中的事件和动画jQuery中的事件加载DOM以浏览器装载文档为例，在页面加载完毕后，浏览器会通过JavaScript为DOM元素添加事件，在常规的 JavaScript代码中，通常使用window.onload方法，而在jQuery中，使用的是$(document).ready()方法。$(document).ready()方法是事件模块中最重要的一个函数，可以极大的提高Web应用程序的响应速度，jQuery就是用$(document).ready()方法来代替传统JavaScript的window.onload方法的。通过使用该方法，可以在DOM载入就绪时就对其进行操纵并调用执行它所绑定的函数。在使用过程中，需要注意$(document).ready()方法和window.onload()方法之间的细微区别。 1.执行时机$(document).ready()方法和window.onload方法有相似的功能，但是在执行时机方面是有区别的。window.onload方法是在网页所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素。而通过jQuery中的$(document).ready()方法注册的事件处理程序，在DOM完全就绪时就可以被调用。此时，网页的所有元素对jQuery而言都是可以访问的，但是，这并不意味着这些元素关联的文件都已经下载完毕。 举一个例子，有一个大型的图库网站，为网页中所有图片添加某些行为，例如单击图片后让它隐藏或显示。如果使用window.onload方法来处理，那么用户必须等到每一幅图片都加载完毕后，才可以进行操作。如果使用jQuery中的$(document).ready()方法来进行设置，只要DOM就绪就可以操作了，不需要等待所有图片下载完毕。很显然，把网页解析为DOM树的速度比把网页中所有的关联文件加载完毕的速度块很多。 另外，需要注意一点，由于在$(document).ready()方法内注册的事件，只要DOM就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用jQuery中另一个关于页面加载的方法--load()方法。load()方法会在元素的onload事件中绑定一个处理事件。如果处理函数绑定给window对象，则会在所有内容(包括窗口、框架、对象和图像等)加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。 123$(window).load(function() &#123; //编写代码&#125;); 等价于JavaScript中的一下代码:123window.onload = function() &#123; //编写代码&#125;; 2.多次使用第一章曾经用一个表格总结过window.onload方法和$(document).ready()方法的区别，现在进行详细讲解。假设网页中有两个函数，JavaScript代码如下: 123456function one() &#123; alert(&quot;one&quot;);&#125;function two() &#123; alert(&quot;two&quot;);&#125; 当网页加载完毕后，通过如下JavaScript代码来分别调用one函数和two函数: 12window.onload = one;window.onload = two; 然而当运行代码后，发现只弹出字符串“two”对话框字符串”one”对话框不能被弹出的原因是JavaScript的onload事件一次只能保存对一个函数的引用，它会自动用后面的函数覆盖前面的函数，因此不能在现有的行为上添加新的行为。为了达到两个函数顺序触发的效果，只能再创建一个新的JavaScript方法来实现，JavaScript代码如下:1234window.onload = function() &#123; one(); two();&#125;; 虽然这样编写代码能解决某些问题，但还是不能满足某些需求，例如有多个JavaScript文件，每个文件都需要用到window.onload方法，这种情况下用上面提到的方法编写代码会非常麻烦。而jQuery的$(document).readt()方法都会在现有行为上追加新的行为，这些行为会根据注册的顺序依次执行。例如如下jQuery代码： 123456789101112function one() &#123; alert(&quot;one&quot;);&#125;function two() &#123; alert(&quot;two&quot;);&#125;$(document).ready(function() &#123; one();&#125;);$(document).ready(function() &#123; two();&#125;); 3.简写方式123$(function() &#123; //编写代码&#125;); 另外，$(document)也可以简写为$().当$()不带参数时，默认参数就是&quot;document&quot;,因此可以简写: 123$().ready(function() &#123; //编写代码&#125;); 事件绑定在文档装载完成后，如果打算为元素绑定事件来完成某些操作，则可以使用bind()方法来对匹配元素进行特定事件的绑定，bind()方法的调用格式为: 1bind(type[,data],fn); bind()方法有3个参数，说明如下:第1个参数是事件类型，类型包括：blur、focus、load、resize、scroll、unload、click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、mouseenter、mouseleave、change、select、submit、keydown、keypress、keyup和error等，当然也可以是自定义名称。第2个参数为可选参数，作为event.data属性值传递给事件对象的额外数据对象。第三个参数则是用来绑定处理函数。 1.基本效果下面通过一个示例来了解bind()方法的用处。假设网页中有一个FAQ，单击“标题”链接将显示内容。HTML代码如下： 123456&lt;div id=&quot;panel&quot;&gt; &lt;h5 class=&quot;head&quot;&gt;什么是jQuery？&lt;/h5&gt; &lt;div class=&quot;content&quot;&gt; xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;/div&gt;&lt;/div&gt; 按照需求，需要完成以下几个步骤。1.等待DOM装载完毕。2.找到“标题”所在的元素，绑定click事件。3.找到“内容”元素，可以轻易地写出如下jQuery代码: 12345$(function() &#123; $(&quot;#panel h5.head&quot;).bind(&quot;click&quot;,function() &#123; $(this).next(&quot;div.content&quot;).show(); &#125;);&#125;) 与ready()方法一样，bind()方法可以多次调用。上面jQuery代码中有一个关键字this，与在JavaScript中的作用一样，this引用的是携带相应行为的DOM元素。为了使该DOM元素能够使用jQuery中的方法，可以使用$(this)将其转换为jQuery对象。 合成事件hover()方法hover()方法的语法结构为： 1hover(enter,leave); hover()方法用于模拟光标悬停事件，当光标移动倒元素上时，会触发指定的第1个函数(enter),当光标移出这个元素时，会触发指定的第2个函数（leave） 1234567$(function() &#123; $(&quot;#panel h5.head&quot;).hover(function() &#123; $(this).next(&quot;div.content&quot;).show(); &#125;,function() &#123; $(this).next(&quot;div.content&quot;).hide(); &#125;);&#125;); 事件冒泡事件对象由于IE-DOM和标准DOM实现事件对象的方法各不相同，导致在不同浏览器中获取事件对象变得比较困难。针对这个问题，jQuery进行了必要的扩展和封装，从而使得在任何浏览器中都能轻松地获取事件对象以及事件对象的一些属性。 停止事件冒泡停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行。在jQuery中提供了stopPropagation()方法来停止事件冒泡。 12345$(&apos;#content&apos;).bind(&quot;click&quot;,function() &#123; var txt = $(&quot;#msg&quot;).html() + &quot;&lt;p&gt;外层div元素被单击.&lt;/p&gt;&quot;; $(&quot;#msg&quot;).html(txt); event.stopPropagation();&#125;); 阻止默认事件在jQuery中，提供了preventDefault()方法来阻止元素的默认行为。jQuery不支持事件捕获。 事件对象的属性1.event.type()方法该方法的作用使可以获取到事件的类型。 1234$(&quot;a&quot;).click(function() &#123; alert(&quot;event.type&quot;); return false;&#125;); 以上代码运行后会返回 1&quot;click&quot; 2.event.preventDefault()方法该方法的作用是阻止默认的事件行为。 3.event.stopPropagation()方法该方法的作用是阻止事件的冒泡。 4.event.target()方法该方法的作用是获取触发事件的元素。jQuery对其封装后，避免了W3C、IE和safari浏览器的不同标准差异。 5.event.relatedTarget()方法在标准DOM中，mouseover和mouseout所发生的元素可以通过event.target()方法来访问，相关元素是通过event.relatedTarget()方法来访问的。event.relatedTarget()方法在mouseover中相当于IE浏览器的event.fromElement()方法，在mouseout中相当于IE浏览器的event.toElement方法，jQuery对其进行了封装，使之能兼容各种浏览器。 6.event.pageX()方法/event.pageY()方法该方法的作用是获取到光标相对于页面的x坐标和y坐标。如果没有使用jQuery时，那么IE浏览器中是用event.x()/event.y()方法，而在Firefox浏览器中是用event.pageX()/event.pageY(）方法。如果页面上有滚动条，则还要加上滚动条的宽度或高度。在IE浏览器中还应该减去默认的2px的边框。 7.event.which()方法该方法的作用是在鼠标单击事件中获取鼠标的左、中、右键，在键盘事件中获取键盘的按键。 8.event.metaKey()方法针对不同的浏览器对键盘中的ctrl按键解释不同，jQuery也进行了封装，并规定event.metaKey()方法为键盘事件中获取ctrl按键。 移除事件可以为同一个元素绑定多个事件，也可以为多个元素绑定同一个事件。假设网页上有一个button元素，使用以下代码为该元素绑定多个相同的事件。 12345678910111213&lt;script&gt; $(function() &#123; $(&quot;#btn&quot;).bind(&quot;click&quot;,function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件1&lt;/p&gt;&quot;); &#125;).bind(&quot;click&quot;,function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件2&lt;/p&gt;&quot;); &#125;).bind(&quot;click&quot;,function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件3&lt;/p&gt;&quot;); &#125;); &#125;);&lt;/script&gt;&lt;button id=&quot;btn&quot;&gt;单击我&lt;/button&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; 1.移除按钮元素上以前注册的事件首先在网页上添加一个移除事件的按钮。 1&lt;button id=&quot;delAll&quot;&gt;删除所有事件&lt;/button&gt; 然后为按钮绑定一个事件，jQuery代码如下: 123$(&quot;#delAll&quot;).click(function() &#123; $(&quot;#btn&quot;).unbind(&quot;click&quot;);&#125;); 2.移除button元素的其中一个事件首先需要为这些匿名处理函数指定一个变量。 123456789$(function() &#123; $(&quot;#btn&quot;).bind(&quot;click&quot;,myFun1 = function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件1&lt;/p&gt;&quot;); &#125;).bind(&quot;click&quot;,myFun2 = function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件2&lt;/p&gt;&quot;); &#125;).bind(&quot;click&quot;,myFun3 = function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定事件3&lt;/p&gt;&quot;); &#125;); &#125;); 然后就可以单独删除某一个事件了，jQuery代码如下: 123$(&quot;#deTwo&quot;).click(function() &#123; $(&quot;#btn&quot;).unbind(&quot;click&quot;,myFun2);&#125;); 另外，对于只需要触发一次，随后就要立即解除绑定的情况，jQuery提供了一种间歇方法–one()方法。One()方法可以为元素绑定处理函数。当处理函数触发一次后，立即被删除。即在每个对象上，事件处理函数只会被执行一次。 模拟操作1.常用模拟以上的例子都是用户必须通过单击按钮，才能触发click事件，但是有时，需要通过模拟用户操作，来达到单击的效果，例如在用户进入页面后，就触发click事件，而不需要用户去主动单击。在jQuery中，可以使用trigger()方法完成模拟操作。例如可以使用下面的代码来触发id为btn的按钮的click事件。 1$(&quot;#btn&quot;).trigger(&quot;click&quot;); 也可以直接用简化写法click()，来达到同样的效果: 1$(&quot;#btn&quot;).click(); 2.触发自定义事件trigger()方法不仅能触发浏览器支持的具有相同名称的事件，也可以触发自定义名称的事件，例如为元素绑定一个”myClick”的事件，jQuery代码如下: 123$(&quot;#btn&quot;).bind(&quot;myClick&quot;,function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;我都自定义事件.&lt;/p&gt;&quot;);&#125;); 想要触发这个事件，可以使用如下代码来实现： 1$(&quot;#btn&quot;).trigger(&quot;myClick&quot;); 3.传递数据trigger(type[,data])方法有两个参数，第1个参数是要触发的事件类型，第2个参数是要传递给事件处理函数的附加数据，以数组形式传递。通常可以通过传递一个参数给回调函数来区别这次事件是代码触发的还是用户触发的。下面是一个传递数据的例子。 1234$(&quot;#btn&quot;).bind(&quot;myClick&quot;,function() &#123; $(&quot;#test&quot;).append(&quot;&lt;p&gt;&quot; + message1 + message2 +&quot;&lt;/p&gt;&quot;);&#125;);$(&quot;#btn&quot;).trigger(&quot;myClick&quot;,[&quot;我都自定义&quot;,&quot;事件&quot;]); 4.执行默认操作trigger()方法触发事件，会执行浏览器默认操作。 1$(&quot;input&quot;).trigger(&quot;focus&quot;); 以上代码不仅会触发为input元素绑定的focus事件，也会使input元素本身得到焦点如果只想触发绑定的focus事件，而不想执行浏览器默认操作，可以使用jQuery中另一个类似的方法–triggerHandler()方法 1$(&quot;input&quot;).triggerHandler(&quot;focus&quot;); 其他用法前面已经对bind()方法进行了介绍，bind()方法不仅能为元素绑定浏览器支持的具有相同名称的事件，也可以绑定自定义事件。不仅如此，bind()方法还能做很多事情。 1.添加事件命名空间，便于管理例如可以把为元素绑定的多个事件类型用命名空间规范起来，jQuery代码如下: 1234567891011121314$(function() &#123; $(&quot;div&quot;).bind(&quot;click.plugin&quot;,function() &#123; $(&quot;body&quot;).append(&quot;&lt;p&gt;click事件&lt;/p&gt;&quot;); &#125;); $(&quot;div&quot;).bind(&quot;mouseover.plugin&quot;,function() &#123; $(&quot;body&quot;).append(&quot;&lt;p&gt;mouseover事件&lt;/p&gt;&quot;); &#125;); $(&quot;div&quot;).bind(&quot;dblclick&quot;,function() &#123; $(&quot;body&quot;).append(&quot;&lt;p&gt;dblclick事件&lt;/p&gt;&quot;); &#125;); $(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).unbind(&quot;.plugin&quot;); &#125;);&#125;); 在所绑定的事件类型后面添加命名空间，这样在删除事件时只需要指定命名空间即可，单击button元素后，”plugin”的命名空间被删除，而不在”plugin”的命名空间的”dblclick”事件依然存在。删除多个事件代码也可以写为以下链式代码，但显示上面的方式写的更少。 1$(&quot;div&quot;).unbind(&quot;click&quot;).unbind(&quot;mouseover&quot;); 3.相同事件名称、不同命名空间执行方法例如可以为元素绑定相同的事件类型，然后以命名空间的不同按需调用，jQuery代码如下 1234567891011$(function() &#123; $(&quot;div&quot;).bind(&quot;click&quot;,function() &#123; $(&quot;body&quot;).append(&quot;&lt;p&gt;click事件&lt;/p&gt;&quot;); &#125;); $(&quot;div&quot;).bind(&quot;click.plugin&quot;,function() &#123; $(&quot;body&quot;).append(&quot;&lt;p&gt;click.plugin事件&lt;/p&gt;&quot;); &#125;); $(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).trigger(&quot;click!&quot;); //注意click后面的感叹号 &#125;);&#125;); 当单击div元素后，会同时触发click事件和click.plugin事件。如果只是单击button元素，则只会触发click事件，而不触发click.plugin事件。注意，trigger(“click!”)后面的感叹号的作用是匹配所有不包含在命名空间中的click方法。如果需要两者都被触发，改为如下代码即可: 1$(&quot;div&quot;).trigger(&quot;click&quot;); jQuery中的动画show()方法和hide()方法1.show()和hide()show()方法和hide()方法是jQuery中最基本的动画方法。在HTML文档里，为一个元素用hide()方法，会将该元素的display样式改为”none”;例如，使用如下代码隐藏element元素。 1$(&quot;element&quot;).hide(); 这段代码的功能与用css()方法设置display属性效果相同: 1element.css(&quot;display&quot;,&quot;none&quot;); show()方法和hide()方法在不带任何参数的情况下，相当于css(“display”,”none/block/inline”)，作用是立即隐藏或显示匹配的元素，不会有任何动画。如果希望在调用show()方法时，元素慢慢地显示出来，可以为show()方法指定一个速度参数。slow—-600毫秒；normal—-400毫秒；fast—-200毫秒 2.fadeIn()方法和fadeOut()方法与show()方法不相同的是，fadeIn()方法和fadeOut()方法只改变元素的不透明度。fadeOut()方法会在指定的一段时间内降低元素的不透明度，直到元素完全消失(“display”,”none”)。fadeIn()方法则相反。 3.slideUp()和slideDown()方法slideUp()方法和slideDown()方法只会改变元素的高度。如果一个元素的display属性值为”none”,当调用slideDown()方法时，这个元素将由上至下延伸显示。slideUp()方法正好相反，元素将由下到上缩短隐藏。 4.自定义动画方法animate()前面已经讲了3种类型的动画。其中show()方法和hide()方法会同时修改元素的多个样式属性，即高度、宽度和不透明度；fadeOut()方法和fadeIn()方法只会修改元素的不透明度；slideDown()方法和slideUp()方法只会改变元素的高度。animate()方法语法结构为： 1animate(params,speed.callback); 参数说明如下：1.params:一个包含样式属性及值的映射，比如{property1:”value1”,property2:”value2”…}2.speed:速度参数，可选3.callback:在动画完成时执行的函数，可选。 1.自定义简单动画前面的几个例子，从不同的方面使元素动了起来。animate()方法也可以使元素动起来，而且animate()方法更具有灵活性。通过animate()方法，能够实现更加精致新颖的动画效果。首先来看一个简单例子，有一个空白的HTML文档，里面有一个id=”panel”的div元素，当div元素被单击后，能在页面上横向飘动。先给这个div元素添加css样式 12345678#panel &#123; position:relative; width:100px; height:100px; border:1px solid #0050d0; background:#96e555; cursor:pointer;&#125; 为了使这个元素动起来，要更改元素的”left”样式属性。需要注意的是在使用animate()方法之前，为了能影响该元素的”top”、””left”、”bottom”和”right”样式属性，必须先把元素的position样式设置为”relative”或者”absolute”。现在添加jQuery代码 12345$(function() &#123; $(&quot;#panel&quot;).click(function() &#123; $(this).animate(&#123;left:&quot;500px&quot;&#125;,3000); &#125;);&#125;); 在本段代码中，首先为id为”panel”创建一个单击事件，然后对元素加入animate()方法，使元素在3秒(3000毫秒)内，向右移动500像素。 2.累加、累减动画在之前的代码中，设置了{left:”500px”}作为动画参数，如果在500px之前加上”+=”或者”-=”符号即表示在当前位置累加或者累减。代码如下: 12345$(function() &#123; $(&quot;#panel&quot;).click(function() &#123; $(this).animate(&#123;left:&quot;+=500px&quot;&#125;,300); //在当前位置累加500px &#125;);&#125;); 3.多重动画1.同时执行多个动画。在上面的例子中，通过控制属性left的值实现了动画的效果，这是一个很单一的动画。如果需要同时执行多个动画，例如在元素向右滑动的同时，放大元素的高度。根据animate()方法的语法结构，可以写出如下的jQuery代码。 12345$(function() &#123; $(&quot;#myImg&quot;).click(function() &#123; $(this).animate(&#123;left:&quot;500px&quot;,height:&quot;200px&quot;&#125;,3000); &#125;);&#125;); 运行代码后，div元素在向右滑动的同时，也会放大高度。2.按顺序执行多个动画上例中，两个动画效果(left:”500px”和height:”200px”)是同时发生的，如果想要按顺序执行动画，例如让div元素先向右滑动，然后再放大它的高度，只需把代码拆开，然后按照顺序写就可以了，jQuery代码如下: 12$(this).animate(&#123;left:&quot;500px&quot;&#125;,3000);$(this).animate(&#123;height:&quot;200px&quot;&#125;,3000); 因为animate()方法都是对同一个jQuery对象进行操作，所以也可以改为链式的写法，代码如下: 1$(this).animate(&#123;left:&quot;500px&quot;&#125;,3000).animate(&#123;height:&quot;200px&quot;&#125;,3000); 这样一来，就满足上文提出的需求了。在”left”这个定位属性改变之前，”height”属性将不会被改变。像这丫能够，动画效果的执行具有先后顺序，称为”动画队列”。4.综合动画接下来将完成更复杂的动画。单击div元素后让它向右移动的同时增大它的高度，并将它的不透明度从50%变换到100%，然后再让它从上到下移动，同时它的宽度变大，当完成这些效果后，让它淡出的方式隐藏。 12345678$(function() &#123; $(&quot;#panel&quot;).css(&quot;opacity&quot;,&quot;0.5&quot;); $(&quot;#panel&quot;).click(function() &#123; $(this).animate(&#123;left:&quot;400px&quot;,height:&quot;200px&quot;,&quot;opacity&quot;:&quot;1&quot;&#125;,3000) .animate(&#123;top:&quot;200px&quot;,width:&quot;200px&quot;&#125;,3000) .fadeOut(&quot;slow&quot;); &#125;);&#125;); 运行代码后，动画效果一步步执行完毕。通过这个例子可以看出，为同意元素应用多重效果后，可以通过链式方式对这些效果进行排队。 动画回调函数在上例中，如果想在最后一步切换元素的CSS样式，而不是隐藏元素: 1css(&quot;border&quot;,&quot;5px solid blue&quot;); 如果只是按照常规的方式，将fadeOut(“slow”)改为css(“border”,”5px solid blue”)并不能得到预期效果。预期的效果是在动画的最后一步改变元素的样式，而实际的效果是，刚开始执行动画的时候，css()方法就被执行了。出现这个问题的原因是css()方法并不会加入到动画队列中，而是立即执行。可以使用回调函数(callback)对非动画方法实现排队。只要把css()方法写在最后一个动画的回调函数里即可。代码如下: 123456$(&quot;#panel&quot;).click(function() &#123; $(this).animate(&#123;left:&quot;400px&quot;,height:&quot;200px&quot;,opacity:&quot;1&quot;&#125;,3000) .animate(&#123;top:&quot;200px&quot;,width:&quot;200px&quot;&#125;,3000,function() &#123; $(this).css(&quot;border&quot;,&quot;5px solid blue&quot;); &#125;)&#125;); 这样一来，css()方法就加入到动画队列中了，从而满足了上文提出的需求。callback回调函数适用于jQuery所有的动画效果方法，例如slideDown()方法的回调函数。 123$(&quot;#element&quot;).slideDown(&quot;normal&quot;,function() &#123; //在效果完成后做其他的事情&#125;); 停止动画和判断是否处于动画状态1.停止元素的动画很多时候需要停止匹配元素正在进行的动画，例如上例的动画，如果需要在某处停止动画，需要使用stop()方法。stop()方法的语法结构为: 1stop([clearQueue][,gotoEnd]); 参数clearQueue和gotoEnd都是可选的参数，为Boolean值(true或false)。clearQueue代表是否清空未执行完的动画队列，gotoEnd代表是否直接将正在执行的动画跳转到末状态。如果直接使用stop()方法，则会停止当前正在进行的动画，如果接下来还有动画等待继续进行，则以当前状态开始接下来的动画。经常会遇到这种情况，在为一个元素绑定hover事件之后，用户把光标移入元素时会触发动画效果，而这个动画还没结束时，用户就将光标移除这个元素了，那么光标移除的动画效果将会被放进队列之中，等待光标移入的动画结束后再执行。因此如果光标移入移除得过快就会导致动画动画效果与光标的动作不一致。此时只要再光标移入、移除动画之前加入stop()方法，就能解决这个问题。stop()方法会结束当前正在进行的动画，并立即执行队列中的下一个动画。以下代码就可以解决刚才的问题。 1234567$(&quot;#panel&quot;).hover(function() &#123; $(this).stop() .animate(&#123;height:&quot;150&quot;,width:&quot;300&quot;&#125;,200);&#125;,function() &#123; $(this).stop() .animate(&#123;height:&quot;22&quot;,width:&quot;60&quot;&#125;,300);&#125;); 如果遇到组合动画，例如： 123456789$(&quot;#panel&quot;).hover(function() &#123; $(this).stop() .animate(&#123;height:&quot;150&quot;&#125;,200) //如果在此时出发了光标移出的事件将执行下面的动画而非光标移出事件的动画 .animate(&#123;width:&quot;300&quot;&#125;,300); &#125;,function() &#123; $(this).stop() .animate(&#123;height:&quot;22&quot;&#125;,200) .animate(&#123;width:&quot;60&quot;&#125;,300);&#125;); 此时只用一个不带参数的stop()方法就显得力不从心了。因为stop()方法只会停止正在进行的动画，如果动画正执行在第1阶段（改变height的阶段），则触发移出事件后，只会停止当前的动画，并继续进行下面的animate({width:”300”},300)动画，而光标移出事件中的动画要等这个动画结束后才会继续执行，这显然不是预期的结果。这种情况下stop()方法的第1个参数就发挥作用了，可以把第1个参数（clearQueue）设置为true，此时程序会把当前元素接下来尚未执行完的动画队列都清空。把上面的的代码改成如下代码，就能实现预期的效果。 123456789$(&quot;#panel&quot;).hover(function() &#123; $(this).stop(true) .animate(&#123;height:&quot;150&quot;&#125;,200) //如果在此时出发了光标移出的事件直接跳过后面的动画队列 .animate(&#123;width:&quot;300&quot;&#125;,300); &#125;,function() &#123; $(this).stop(true) .animate(&#123;height:&quot;22&quot;&#125;,200) .animate(&#123;width:&quot;60&quot;&#125;,300)&#125;); 第2个参数（gotoEnd）可以用于让正在执行的动画直接到达结束时刻的状态，通常用于后一个动画需要基于前一个动画的末状态的情况，可以通过stop(false,true)这种方式来让当前动画直接到达末状态。当然两者结合起来使用stop(true,true),即停止当前动画并直接到达当前动画的末状态，并清空动画队列。注意，jQuery只能设置正在执行的动画的最终状态，而没有提供直接到达未执行动画队列最终状态的方法。例如有一组动画: 1234$(&quot;div.content&quot;) .animate(&#123;width:&quot;300&quot;&#125;,200) .animate(&#123;height:&quot;150&quot;&#125;,300) .animate(&#123;opacity:&quot;.2&quot;&#125;,2000) 无论怎么设置stop()方法，均无法在改变”width”或者”height”时，将此div元素的末状态变成300 X 150 的大小，并且设置透明度为0.2. 2.判断元素是否处于动画状态在使用animate()方法的时候，要避免动画积累而导致的动画与用户的行为不一致。当用户快速在某个元素上执行animate()动画时，就会出现动画积累。解决方法是判断元素是否正处于动画状态，如果元素不处于动画状态，才为元素添加新的动画，否则不添加。代码如下: 123if (!$(element).is(&quot;:animated&quot;)) &#123; //判断元素是否正处于动画状态 //如果当前没有进行动画，则添加新动画&#125; 这个判断方法在animate()动画中经常被用到，需要特别注意。 动画方法概括从基本动画方法hide()和show()到fadeIn()和fadeOut()，然后到slideUp()和slideDown().再到自定义动画方法animate().在介绍如此多的动画方法后，现总结概括如下：1.改变样式属性 需要特别注意animate()方法，可以使用它来替代其他所有动画方法。用animate()方法代替show()方法 1$(&quot;p&quot;).animate(&#123;height:&quot;show&quot;,width:&quot;show&quot;,opacity:&quot;show&quot;&#125;,400) 等价于 1$(&quot;p&quot;).show(400); 用animate()方法代替fadein()方法 1$(&quot;p&quot;).animate(&#123;opacity:&quot;show&quot;&#125;,400) 等价于 1$(&quot;p&quot;).fadeIn(400); 用animate()方法代替slideDown()方法 1$(&quot;p&quot;).animate(&#123;height:&quot;show&quot;&#125;,400); 等价于 1$(&quot;p&quot;).slideDown(400); 用animate()方法代替fadeTo()方法 1$(&quot;p&quot;).animate(&#123;opacity:&quot;0.6&quot;&#125;,400) 等价于 1$(&quot;p&quot;).fadeTo(400,0.6); 事实上，这些动画就是animate(）方法的一种内置了特定样式属性的简写形式。在animate()方法中，这些特定样式的属性值可以为”show”、”hide”，也可以是自定义数字。 2.动画队列1.一组元素上的动画效果当在一个animate()方法中应用多个属性时，动画是同时发生的。当以链式的写法应用动画方法时，动画是按照顺序发生的2.多组元素上的动画效果默认情况下，动画都是同时发生的。当以回调的形式应用动画方式时，动画是按照回调顺序发生的。另外，在动画方法中，要注意其他非动画方法会插队，例如css()方法要使非动画方法也按照顺序执行，需要把这些方法写在动画方法的回调函数中。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQuery-DOM操作]]></title>
    <url>%2F2017%2F12%2F11%2F%E9%94%8B%E5%88%A9%E7%9A%84jQuery-DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[很多道理，听别人说的时候以为是杯白开水，自己体会到的时候才知道是瓶二锅头。 jQuery中的DOM操作查找节点1.查找元素节点获取元素点并打印出它的文本内容。html代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;dom&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p title=&quot;选择喜欢的。&quot;&gt;你最喜欢的水果是？&lt;/p&gt; &lt;ul&gt; &lt;li title=&apos;苹果&apos;&gt;苹果&lt;/li&gt; &lt;li title=&apos;橘子&apos;&gt;橘子&lt;/li&gt; &lt;li title=&apos;菠萝&apos;&gt;菠萝&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 123var $li = $(&quot;ul li:eq(1)&quot;);var li_txt = $li.text();console.log(li_txt); 2.查找属性节点利用jQuery选择器查找到需要的元素之后，就可以使用attr()方法来获取它的各种属性值，attr()方法的参数可以是一个，也可以是两个，当参数是一个时，则时要查询的属性的名字 123var $para = $(&quot;p&quot;);var p_txt = $para.attr(&quot;title&quot;);console.log(p_txt); 创建节点创建元素节点1234var $li_1 = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);var $li_2 = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);$(&quot;ul&quot;).append($li_1);$(&quot;ul&quot;).append($li_2); 创建文本节点1234var $li_1 = $(&quot;&lt;li&gt;香蕉&lt;/li&gt;&quot;);var $li_2 = $(&quot;&lt;li&gt;雪梨&lt;/li&gt;&quot;);$(&quot;ul&quot;).append($li_1);$(&quot;ul&quot;).append($li_2); 创建属性节点1234var $li_1 = $(&quot;&lt;li title=&apos;香蕉&apos;&gt;香蕉&lt;/li&gt;&quot;);var $li_2 = $(&quot;&lt;li title=&apos;雪梨&apos;&gt;雪梨&lt;/li&gt;&quot;);$(&quot;ul&quot;).append($li_1);$(&quot;ul&quot;).append($li_2); 插入节点动态创建HTML元素并没有实际用处，还需要将新创建的元素插入文档中，将新创建的节点插入文档最简单的办法是，让它成为这个文档的某个节点的子节点，前面使用了一个插入节点的方法append()，它会在元素内部追加新创建的内容。 删除节点如果文档中某一个元素多余，那么应当将其删除。jQuery提供了两种删除节点的方法，remove()和empty()。 1$(&quot;ul li:eq(1)&quot;).remove(); 当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。 empty()方法 严格来讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中所有的后代节点。 复制节点复制节点也是常用的DOM操作之一，例如某个购物网站的效果，用户不仅可以通过单击商品下方的&quot;选择&quot;按钮购买相应的产品，也可以通过鼠标拖动商品并将其放到购物车中。这个商品拖放功能就是用的复制节点。将用户选择的商品所处的节点元素复制一次，并将其跟随鼠标移动，从而达到一下购物车效果。 clone()方法，在clone()方法中传递了一个参数true，它的含义是复制元素的同时复制元素所绑定的事件。因此该元素的副本也同样具有复制功能。 替换节点如果要替换某个节点，jQuery提供了相应的方法，即replaceWith()和replaceAll()。replaceWith()方法的作用是将所有匹配的元素都替换成指定的HTML或者DOM元素。 1$(&quot;p&quot;).repalceWith(&quot;&lt;strong&gt;你最不喜欢的事？&lt;/strong&gt;&quot;); 也可以使用jQuery中另一个方法replaceAll()来实现，该方法与replaceWith()方法的作用相同，只是颠倒了replaceWith()操作。 1$(&quot;&lt;strong&gt;你最不喜欢的事是？&lt;/strong&gt;&quot;).replaceAll(&quot;p&quot;); 包裹节点 如果要将某个节点用其他标记包裹起来，jQuery提供了相应的方法，即wrap()。该方法对于需要在文档中插入额外的结构化标记非常有用，而且它不会破坏原始文档的语义。 1$(&quot;strong&quot;).wrap(&quot;&lt;b&gt;&lt;/b&gt;&quot;); 得到的结果如下: 1&lt;b&gt;&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;/strong&gt;&lt;/b&gt; 包裹节点操作还有其他两个方法，即wrapAll()和wrapInner()。1.wrapAll方法该方法会将所有匹配的元素用一个元素来包裹。它不同于wrap()方法，wrap()方法是将所有的元素进行单独的包裹。 12&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;/strong&gt;&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;/strong&gt; 1$(&quot;strong&quot;).wrapAll(&quot;&lt;b&gt;&lt;/b&gt;&quot;); 效果 1234&lt;b&gt;&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;/strong&gt;&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;/strong&gt;&lt;/b&gt; 2.wrapInner()方法该方法将每一个匹配的元素的子内容用其他结构化的标记包裹起来。例如可以使用它来包裹标签的子内容。 1$(&quot;strong&quot;).wrapInner(&quot;&lt;b&gt;&lt;/b&gt;&quot;); 效果 1&lt;strong title=&quot;选择你最喜欢的水果.&quot;&gt;&lt;b&gt;你最喜欢的水果是？&lt;/b&gt;&lt;/strong&gt; 属性操作在jQuery中，用attr()方法来获取和设置元素属性，removeAttr()方法来删除元素属性。 1.获取属性和设置属性12var $para = $(&quot;p&quot;);var p_txt = $para.attr(&quot;title&quot;); //获取&lt;p&gt;元素节点属性title 1$(&quot;p&quot;).attr(&quot;title&quot;,&quot;your title&quot;); //设置单个的属性值 如果要一次性设置多个属性 1$(&quot;p&quot;).attr(&#123;&quot;title&quot;:&quot;your title&quot;,&quot;name&quot;:&quot;test&quot;&#125;); //将一个&quot;名/值&quot;形式的对象设置为匹配元素的属性 jQuery中的很多方法都是同一个函数实现获取(getter)和设置(setter)的，例如上面的attr()方法，既能设置元素属性的值，也能获取元素属性的值，类似的还有html()、text()、height()、width()、val()和css()方法。 2.删除属性在某些情况下，需要删除文档中某个元素的特定属性，可以使用removeAttr()方法来完成该任务。 1&lt;p title=&quot;选择你最喜欢的水果.&quot;&gt;你最喜欢的水果是？&lt;/p&gt; 1$(&quot;p&quot;).removeAttr(&quot;title&quot;); 效果 1&lt;p&gt;你最喜欢的水果是？&lt;/p&gt; 样式操作1.获取样式和设置样式HTML代码如下： 1&lt;p class=&quot;myClass&quot; title=&quot;选择你最喜欢的水果.&quot;&gt;你做喜欢的水果是？&lt;/p&gt; 在上面的代码中，class也是p元素的属性，因此获取class和设置class都可以使用attr()来完成。例如使用attr()方法来获取p元素的class，jQuery代码如下： 1var p_class = $(&quot;p&quot;).attr(&quot;class&quot;); 也可以使用attr()方法来设置p元素的class，jQuery代码如下： 1$(&quot;p&quot;).attr(&quot;class&quot;,&quot;high&quot;); 在大多数情况下，它是将原来的class替换为新的class，而不是在原来的基础上追加新的class。运行代码后，上面的HTML代码将变为如下结构: 1&lt;p class=&quot;high&quot; title=&quot;选择你最喜欢的水果.&quot;&gt;你最喜欢的水果是？&lt;/p&gt; 2.追加样式jQuery提供了专门的addClass()方式来追加样式。为了使例子更容易理解，首先在style标签里添加另一组样式。 12345678910&lt;style&gt;.high &#123; font-weight:bold; color:red;&#125;.another &#123; font-style:italic; color:blue;&#125;&lt;/style&gt; 然后在网页中添加一个“追加class类”的按钮，按钮的事件如下： 123$(&quot;input:eq(2)&quot;).click(function() &#123; $(&quot;p&quot;).addClass(&quot;another&quot;);&#125;); 3.移除样式要删除class的某个值，那么可以使用与addClass()方法相反removeClass()方法来完成，它的作用是从匹配的元素中删除全部或者指定的class。另外，还可以利用removeClass()方法的一个特性来完成同样的效果。当它不带参数时，会将class的值全部删除。 4.切换样式在之前的案例研究中介绍了一个方法，即toggle(),jQuery代码如下： 12345$toggleBtn.toggle(function() &#123; //显示元素 代码3 &#125;,function() &#123; //隐藏元素 代码4&#125;); toggle()方法此处的作用是交替执行代码3和代码4两个函数，如果元素原来是显示的，则隐藏它；如果元素原来是隐藏的，则显示它。此时，toggle()方法主要是控制行为上的重复切换。另外jQuery还提供了一个toggleClass()方法控制样式上的重复切换。如果类名存在则删除它，如果类名不存在则添加它。 5.判断是否含有某个样式hasClass()可以用来判断元素中是否含有某个class，如果有，则返回true，否则返回false。 设置和获取HTML、文本和值*1.html()方法**此方法类似于JavaScript中的innerHTML属性，可以用来读取或这设置某个元素中的HTML内容。html()方法可以用于XHTML文档，但不能用于XML文档 2.text()方法此方法类似于JavaScript中的innerText属性，可以用来读取或者设置某个元素中的文本内容。1.JavaScript中的innerText属性并不能在Firefox浏览器下运行，而jQuery的text()方法支持所有的浏览器。2.text()方法对HTML文档和XML文档都有效 3.val()方法此方法类似于JavaScript中的value属性，可以用来设置和获取元素的值。无论元素是文本框、还是下拉列表还是单选框。它都可以返回元素的值。如果元素为多选，则返回一个包含所有选择的值的数组。val()方法还有另外一个用处，就是它能使select（下拉列表框）、checkbox(多选框)和radio(单选框)相应的选项被选中，在表单操作中会经常用到。 遍历节点1.children()方法该方法用于取得匹配元素的子元素集合。children()方法只考虑子元素而不考虑任何后代元素 2.next()该方法用于取得匹配元素后面紧邻的同辈元素。 3.prev()该方法用于取得匹配元素前面紧邻的同辈元素。 4.siblings()方法该方法用于取得匹配元素前后所有的同辈元素。 5.closest()它用来取得最近的匹配元素。首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，逐级向上直到找到匹配选择器的元素，如果什么都没找到则返回一个空的jQuery对象。 CSS-DOM操作CSS-DOM技术简单来说就是读取和设置style对象的各种属性。style属性很有用，但最大不足使无法通过它来提取到通过外部CSS设置的样式信息，然而在jQuery中，这些都是非常简单的。 可以直接利用css()方法获取元素的样式属性 在jQuery中还有另外一种方法也可以获取元素的高度，即height()。它的作用是取得匹配元素当前计算的高度值(px)。 1.在jQuery1.2版本以后的height()方法可以用来获取window和document的高度。2.两者的区别是：css()方法获取的高度值与样式的设置有关，可能会得到”auto”,也可能得到”10px”之类的字符串；而height()方法获取的高度值则是元素在页面中的实际高度，与样式的设置无关，并且不带单位。 与height()方法对应的还有一个width()方法，它可以取得匹配元素的宽度值。 1.offset方法 它的作用是获取元素在当前视窗的相对偏移，其中返回的对象包含两个属性，即top和left，它只对可见元素有效。 2.position方法 它的作用是获取元素相对与最近一个position样式属性设置为relative和absolute的祖父节点的相对偏移，与offset()一样，它返回的对象也包括两个属性，即top和left。 3.scrollTop()方法和scrollLeft()方法 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左端的距离。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编写可维护的代码]]></title>
    <url>%2F2017%2F12%2F05%2FJavaScript%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[每一天看你和阳光都在，那就是我要的未来。 基本的格式化缩进层级4个空格缩进，最好统一tab为4个字符。 语句结尾结尾分号 产生错误的例子 123456789101112131415//原始代码function getData() &#123; return &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot; &#125;//分析器会它理解function getData() &#123; return; &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot; &#125;;&#125; 可以通过将左花括号移至与return同一行的位置来修复这个问题。 1234567//这段代码工作正常，尽管没有用分号function getData() &#123; return &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas &#125;&#125; 行的长度80个字符 换行通常我们会在运算符后换行，下一行会增加两个层级的缩进（8个字符） 例外：当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐，例如 12var result = something + antherThing + yetAnotherThing + somethingElse + anotherSomethingElse; 空行 在方法之间 在方法的局部和语句之间 在多行或单行注释之前 在方法内的逻辑片段之间插入空行，提高可读性 命名驼峰命名法 驼峰式大小写命名是由小写字母开始的，后续每个单词首字母都大写。 变量和函数变量名应当总是遵循驼峰小大写命名法，并且前缀是名词。以名词作为前缀可以让变量和函数区分开来，因为函数名前缀应当是动词。 123456789101112131415//好的写法var count = 10;var myName = &quot;Nicholas&quot;;var found = true;//不好的写法:变量像函数var getCount = 10;var isFound = true;//好的写法function getName() &#123; return myName;&#125;//不好的写法:函数看起来像变量function theName() &#123; return myName;&#125; 动词常见的约定 动词 含义 can 函数返回一个布尔值 has 函数返回一个布尔值 is 函数返回一个布尔值 get 函数返回一个非布尔值 set 函数用来保存一个值 常量在ECMAScript6，JavaScript中并没有真正的常量的概念。然而，为了区分普通的变量和常量，它使用大写字母和下划线来命名。 构造函数在JavaScript中，构造函数只不过是前面冠以new运算符的函数，用来创建对象。语言本身已经包含了很多内置构造函数，比如Object和RegExp,同样开发者也可以创建自己的构造函数来生成新类型。 12345678//好的做法function Person() &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var me = new Person(&quot;Nicholas&quot;); 直接量字符串1234//合法的JavaScript代码var name = &quot;Nicholas says,\&quot;Hi.\&quot;&quot;;//也是合法JavaScript代码var name = &apos;Nicholas says.&quot;Hi&quot;&apos;; 在这段代码中，在使用双引号括起来的字符串里需要对双引号进行转义，而在使用单引号括起来的字符串里则不必如此。 nullnull是一个特殊值，但我们常常误解它，将它和undefined搞混。在下列场景中应当使用null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，用作参数传入。 当函数的返回值期望是对象时，用作返回值传出。 还有下面一些场景不应当使用null 不要使用null是否传入了某个参数。 不要用null来检测一个未初始化的变量。 示例代码 1234567891011121314151617181920212223242526//好的用法var person = null;//好的用法function getPerson() &#123; if (condition) &#123; return new Person(&quot;Nicholas&quot;); &#125; else &#123; return null; &#125;&#125;//好的用法var person = getPerson();if (person !== null) &#123; doSomething();&#125;//不好的写法:用来和未初始化的变量比较var person;if (person != null) &#123; doSomething();&#125;//不好的写法:检测是否传入了参数function doSomething(arg1,arg2,arg3,arg4) &#123; if (arg4 != null) &#123; doSomethingElse(); &#125;&#125; 理解null最好的方式是将它当作对象的占位符。这个规则在所有的主流编程规范中都没有提及，但对于全局可维护性来说至关重要。 对象直接量创建最流行的一种做法是使用对象直接量，在直接量上中直接写出所有属性，这种方式可以取代先显示地创建Object的实例然后添加属性的这种做法。 123456789//不好的写法var book = new Object();book.title = &quot;Maintainable JavaScript&quot;;book.author = &quot;Nicholas C. Zakas&quot;;//好的写法var book = &#123; title:&quot;Maintainable JavaScript&quot;, author:&quot;Nicholas C. Zakas&quot;&#125;; 数组直接量和对象直接量类似，数组直接量是JavaScript中定义数组最简洁的一种方式。 123456//不好的写法var colors = new Array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;);var numbers = new Array(1,2,3,4);//好的做法var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];var numbers = [1,2,3,4];]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载document.compatMode属性]]></title>
    <url>%2F2017%2F11%2F22%2F%E8%BD%AC%E8%BD%BDdocument-compatMode%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[成熟不是心变老，是泪在眼里打转还能笑。 document.compatMode属性document.compatMode用来判断当前浏览器采用的渲染方式。官方解释：BackCompat：标准兼容模式关闭。CSS1Compat：标准兼容模式开启。当document.compatMode等于BackCompat时，浏览器客户区宽度是document.body.clientWidth； 当document.compatMode等于CSS1Compat时，浏览器客户区宽度是document.documentElement.clientWidth。 浏览器客户区高度、滚动条高度、滚动条的Left、滚动条的Top等等都是上面的情况。一个准确获取网页客户区的宽高、滚动条宽高、滚动条Left和Top的代码：12345678910111213141516if (document.compatMode == \&quot;BackCompat\&quot;) &#123;cWidth = document.body.clientWidth;cHeight = document.body.clientHeight;sWidth = document.body.scrollWidth;sHeight = document.body.scrollHeight;sLeft = document.body.scrollLeft;sTop = document.body.scrollTop;&#125;else &#123; //document.compatMode == \&quot;CSS1Compat\&quot;cWidth = document.documentElement.clientWidth;cHeight = document.documentElement.clientHeight;sWidth = document.documentElement.scrollWidth;sHeight = document.documentElement.scrollHeight;sLeft = document.documentElement.scrollLeft == 0 ? document.body.scrollLeft : document.documentElement.scrollLeft;sTop = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop;&#125; （以上代码兼容目前流行的全部浏览器，包括：IE、Firefox、Safari、Opera、Chrome）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQuery-jQuery选择器]]></title>
    <url>%2F2017%2F11%2F18%2F%E9%94%8B%E5%88%A9%E7%9A%84jQuery-jQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[你未看此花时，此话与汝心同归于寂。你来看此花时，则此花颜色一时明白起来，便知此花不在你心外。 jQuery选择器jQuery中的完全继承了CSS的风格。利用jQuery选择器，可以非常便捷和快速地找出特定地DOM元素，然后为它们添加相应的行为，而无需担心浏览器是否支持这一选择器。学会使用选择器是学习jQuery的基础，jQuery的行为规则都必须在获取到元素后才能生效。 jQuery选择器的写法与CSS选择器的写法十分相似，只不过两者的作用效果不同，CSS选择器找到元素后是添加样式，而jQuery选择器找到元素后是添加行为。需要特别说明的是，jQuery中涉及操作CSS样式的部分比单纯的CSS功能更为强大，并且拥有跨浏览器的兼容性。 jQuery选择器的优势 1.简洁的写法 $()函数在很多JavaScript类库中都被作为一个选择器函数来使用，在jQuery中也不例外。其中，$(&quot;#ID&quot;)用来代替document.getElementById()函数，即通过ID来获取元素；$(&quot;tagName&quot;)用来代替document.getElementsByTagName()函数，即通过标签名获取HTML元素。 2.支持CSS1到CSS3选择器 jQuery选择器支持CSS1、CSS2的全部和CSS3的部分选择器，同时它也有少量独有的选择器，因此对拥有一定CSS基础的开发人员来说，学习jQuery选择器是件非常容易的事，而对于没有接触过CSS技术的开发人员来说，在学习jQuery选择器的同时也可以掌握CSS选择器的基本规则。 使用CSS选择器时，开发人员需要考虑主流浏览器是否支持某些选择器。而在jQuery中，开发人员则可以放心使用jQuery选择器而无需考虑浏览器是否支持这些选择器。 3.完善的处理机制 使用jQuery选择器不仅比使用传统的getElementById()和getElementsByTagName()函数简洁得多，而且还能避免某些错误。看下面这个例子，代码如下： 1234&lt;div&gt;test&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;tt&quot;).style.color = &quot;red&quot;;&lt;/script&gt; 运行上面的代码，浏览器就会报错，原因是网页中没有id为”tt”的元素。改进后的代码如下： 123456&lt;div&gt;test&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; if (document.getElementById(&quot;tt&quot;)) &#123; document.getElementById(&quot;tt&quot;).style.color = &quot;red&quot;; &#125;&lt;/script&gt; 这样就可以避免浏览器报错，但如果要操作的元素很多，可能对每个元素都要进行一次判断，大量重复的工作使开发人员感到厌倦，而jQuery在这方面问题上的处理是非常不错的，即使使用jQuery获取网页中不存在的元素也不会报错，看下面的例子，代码如下： 1234&lt;div&gt;test&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#tt&quot;).css(&quot;color&quot;,&quot;red&quot;); //这里无需判断$(&quot;#tt&quot;)是否存在&lt;/script&gt; 有了这个预防措施，即使以后因为某种原因删除网页上某个以前使用过的元素，也不用担心这个网页的javascript代码会报错。而需要注意的是，$(“#tt”)获取的永远是对象，即使网页上没有元素。因此当要使用jQuery检查某个元素在网页上是否存在时，不能使用以下代码： 123if ($(&quot;#tt&quot;)) &#123; //do something&#125; 而应该根据获取到元素的长度来判断，代码如下： 123if ($(&quot;#tt).length &gt; 0) &#123; //do something&#125; 或者转化成DOM对象来判断，代码如下: 123if ($(&quot;#tt&quot;)[0]) &#123; //do something&#125; jQuery选择器jQuery选择器分为基本选择器、层次选择器、过滤选择器和表单选择器。在下面的章节中将分别用不同的选择器来查找HTML代码中的元素并对其进行简单的操作。为了能更清晰、直观地讲解选择器，首先需要设计一个简单的页面，里面包含各种&lt;div&gt;元素和&lt;span&gt;元素，然后使用jQuery选择器来匹配元素并调整它们的样式。 基本选择器基本选择器是jQuery中最常用的选择器，也是最简单的选择器，它通过元素id、class和标签名等来查找DOM元素。在网页中，每个id名称只能使用一次，class允许重复使用。 基本选择器的介绍说明如下: 选择器 描述 返回 示例 id 根据给定的id匹配一个元素 单个元素 $(“#test”)选取id为test的元素 .class 根据给定的类名匹配元素 集合元素 $(“.test”)选取所有class为test的元素 element 根据给定的元素名匹配元素 集合元素 $(“p”)选取所有的元素 * 匹配所有元素 集合元素 $(“*”)选取所有的元素 selector1,selector2….,selectorN 将每一个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.myClass”选取所有,和拥有class为myClass的标签的一组元素) 层次选择器如果想通过DOM元素之间的层次关系来获取特定元素，例如后代元素、子元素、相邻元素和兄弟元素等，那么层次选择器是一个非常好的选择。层次选择器的介绍如下: 过滤选择器过滤选择器主要是通过特定的过滤规则来筛选出所需的DOM元素，过滤规则CSS中的伪类选择器语法相同，即选择器都以一个冒号（:）开头。按照不同的过滤规则，过滤选择器可以分为基本过滤、内容过滤、可见性过滤、属性过滤、子元素过滤和表单对象属性过滤选择器。 1.基本过滤选择器 2.内容过滤选择器 内容过滤选择器的过滤规则主要体现在它所包含的子元素或文本内容上。内容过滤选择器的介绍如下: 3.可见性过滤选择器 可见性过滤选择器是根据元素的可见和不可见状态来选择相应的元素。可见性过滤选择器的介绍如下： 4.属性过滤选择器 属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。属性过滤选择器的介绍如下： 5.子元素过滤选择器 子元素过滤选择器的过滤规则相对于其他选择器稍微有些复杂，不过没关系，只要将元素的父元素和子元素区分清楚，那么使用起来也非常简单。另外还注意它与普通的过滤选择器的区别。 6.表单对象属性过滤选择器 此对象主要是对所选择的表单元素进行过滤。例如选择被选中的下拉框，多选框等。 表单选择器为了使用户能够更加灵活地操作表单，jQuery中专门加入了表单选择器，利用这个选择器，能极其方便地获取到表单地某个或某类型地元素。 选择器中地一些注意事项选择器中含有特殊符号的注意事项1.选择器中含有”.”、”#”、”(“或”[“等特殊字符根据W3C的规定，属性值中使不能含有这些特殊字符的，但在实际项目中偶尔会遇到表达式中含有”#”和”.”等特殊字符，如果按照普通的方式去处理出来的话就会出错。解决此类错误的方法是使用转义符转义HTML代码如下: 12&lt;div id=&quot;id#b&quot;&gt;bb&lt;/div&gt;&lt;div id=&quot;id[1]&quot;&gt;cc&lt;/div&gt; 如果按照普通的方式来获取，例如： 12$(&quot;#id#b&quot;);$(&quot;#id[1]&quot;); 以上代码不能正确获取到元素，正确的写法如下: 12$(&quot;#id\\#b&quot;); //转义特殊字符&quot;#&quot;$(&quot;&quot;#id\\[1\\]); //转义特殊字符&quot;[ ]&quot; 选择器中含有空格的注意事项 选择器中的空格也是不容忽视的，多一个空格或少一个空格也许会得到截然不同的结果。看下面这个例子，它的HTML代码如下： 12345678&lt;div class=&quot;test&quot;&gt; &lt;div style=&quot;display:none;&quot;&gt;aa&lt;/div&gt; &lt;div style=&quot;display:none;&quot;&gt;bb&lt;/div&gt; &lt;div style=&quot;display:none;&quot;&gt;cc&lt;/div&gt; &lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;dd&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;ee&lt;/div&gt;&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;ff&lt;/div&gt; 使用如下jQuery选择器分别获取它们 123456var $t_a = $(&apos;.test :hidden&apos;); //带空格的jQuery选择器var $t_b = $(&apos;.test:hidden&apos;); //不带空格的jQuery选择器var len_a = $t_a.length;var len_b = $t_b.length;alert(&quot;$(&apos;.test :hidden&apos;) = &quot; + len_a); //输出4alert(&quot;$(&apos;.test:hidden&apos;)= &quot; + len_b); //输出3 之所以会出现不同的结果，是因为后代选择器与过滤选择器的不同 1var $t_a = $(&apos;.test :hidden&apos;); 以上代码是选取class为””test”的元素里面的隐藏元素。 1var $t_b = $(&apos;.test:hidden&apos;); 则是选取隐藏的class为”test”的元素. 其他选择器jQuery提供的选择器扩展虽然jQuery提供了许多实用的选择器，但还是有可能不能满足各种多变的业务需要，不过jQuery选择器是可以进一步扩展的。 1.MoreSelectors for jQuery 这是一个jQuery的插件，用于增加更多的选择器，例如.color可以匹配颜色，:colIndex可以匹配表格中的列，:focus可以匹配获取焦点的元素等等。 2.Basic XPath 这个插件可以让用户使用基本的XPath。jQuery最开始支持XPath选择器，但由于使用人数不多，且降低了选择器匹配的效率，因此在1.2以后的版本中取消了默认对XPath选择器的支持，改为通过插件来实现。 其他使用CSS选择器的方法除了jQuery提供了强大的选择器支持外，也有其他一些JavaScript脚本也提供了此类纯粹的CSS选择器的支持。 1.document.getElementBySelector()早在2003年，Simon Willison就编写了该脚本，它的作用是通过选择器来获取文档元素。读者可以通过以下代码获取元素 1document.getElementBySelector(&apos;#div#main p a.external&apos;); 该版本最新版本为0.4版，更新日期为2003年3月25日 2.cssQuery()这是Dean Edwards编写的一款利用CSS选择器查找元素的脚本。支持所有CSS1、CSS2以及部分CSS3选择器，jQuery的选择器其实是源自于此，它支持一些jQuery尚不支持的选择器，例如E：link、E：nth-child、E：root、E：target和E[fool=”bar”]等。语法结构如下 1elements = cssQuery(selector[,form]); 3.querySelctorAll()这不是一个脚本库，而是W3C在Selector API草案中提到的方法，该草案的最新版本是在2007年12月21日发布的。此方法也是用于实现通过CSS选择器来获取元素的。IE8的Beta2中已经率先实现了此方法。相信其他几大浏览器也很快实现此方法。JQuery的作者John Resig也表示将会利用querySelectorAll()这个浏览器原生的方法来重jQuery的选择器，同时增加一些jQuery扩展的选择器，届时jQuery选择器的执行效率也将大大提高。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IndexedDB详细介绍]]></title>
    <url>%2F2017%2F11%2F10%2FIndexedDB%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[自爱，沉稳，而后爱人。 IndexedDB介绍： IndexedDB是在浏览器中保存结构化数据的一种数据库。替代目前已被废弃的Web SQL Database API而出现的，IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在后期执行，然后如果成功则返回结果。差不多每一次IndexedDB操作，都需要你注册onerror或onsuccess事件处理程序，以确保适当地处理结果。 Indexed将是一个作为API宿主的全局对象。 首先第一步是要打开它indexeDB.open();如果传入的数据库已经存在，就会发送一个打开它的请求；如果传入的数据的数据库不存在，就会发送一个创建并打开它的请求。执行如下代码 12var request = indexedDB.open(&quot;admin&quot;);console.log(request); 效果如下调用indexDB.open();返回了一个IDBOpenDBRequest对象，可以看到这个对象上的onerror、onsuccess、onupgradeneeded事件都为空，result显示的是创建成功了的IndexDB数据库的实例，但是这个实例我们要取到的话，只能在onsuccess事件中，测试代码 123456var db;var request = indexedDB.open(&quot;admin&quot;);request.onsuccess = function() &#123; db = event.target.result; console.log(db);&#125; 效果如下：从图中，我们可以看到我们创建的数据库实例，名字为admin，objectStoreNames是这个数据库中的储存空间的名字，里面为空，后面会解释这个，版本默认设置了1 对象储存空间 即上面的objectStoreNames中的内容，这个空间中是我们储存数据的地方，如何向数据库中创建这个存储空间，这就要在onupgradeneeded事件中进行，但是要触发这个事件，就是要更新数据库的版本号，新打开的版本号要大于默认版本号，测试代码如下 1234567891011121314151617181920212223242526272829303132var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125; 效果如下： 从这两张图可以看出我们在名为admin的数据库中创建了users的储存空间，分别储存了三个对象，第一张图中，可以看到indexName为空，这个是索引，是我们之后要介绍的内容，这里先知道下，keyPath是键值，用对象中的username，以便我们查询，添加之类操作获取对象的通行证，当然前面的索引也是对这个的一个加强，我们默认会设置一个键，但是可以利用索引再创建其他副键，以便方便数据库操作，后面会做介绍，我们还可以看到name为”users”,transaction是事务，基本来说我们后续的操作都要围绕事务来进行，下面我们来说事务。 事务在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125;//事务相关的操作//跟据键值获取对象function getData() &#123; var transaction = db.transaction(&quot;users&quot;,&apos;readwrite&apos;); var store = transaction.objectStore(&quot;users&quot;); var request = store.get(&quot;007&quot;); request.onsuccess = function(event) &#123; var result = event.target.result; console.log(result.firstName); &#125;;&#125;//因为这里要调用onsucess时候保存的db的实例，但是因为异步操作，如果不用超时调用，可能db还没有获取到！setTimeout(function() &#123; getData();&#125;,500); 结果我将操作都一次性写出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var db;var request = indexedDB.open(&quot;admin&quot;,2);request.onsuccess = function() &#123; db = event.target.result;&#125;var users = [ &#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot; &#125;, &#123; username: &quot;ace&quot;, firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, password: &quot;bar&quot; &#125;, &#123; username: &quot;foobar&quot;, firstName: &quot;Michael&quot;, lastName: &quot;Johnson&quot;, password: &quot;secret&quot; &#125; ];request.onupgradeneeded = function() &#123; var store = db.createObjectStore(&quot;users&quot;,&#123;keyPath:&quot;username&quot;&#125;); for (var i = 0;i &lt; users.length;i++) &#123; store.add(users[i]); &#125; console.log(store);&#125;//事务相关的操作//跟据键值获取对象function getData() &#123; var transaction = db.transaction(&quot;users&quot;,&apos;readwrite&apos;); var store = transaction.objectStore(&quot;users&quot;); var request = store.get(&quot;007&quot;); request.onsuccess = function(event) &#123; var result = event.target.result; console.log(result.firstName); &#125;;&#125;//更新function updataData() &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); var request = store.get(&apos;007&apos;); request.onsuccess = function() &#123; var result = event.target.result; result.firstName = &apos;jack&apos;; store.put(result); &#125;;&#125;//删除function deleteData(key) &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); store.delete(key);&#125;//添加function addData() &#123; var transaction = db.transaction(&apos;users&apos;,&apos;readwrite&apos;); var store = transaction.objectStore(&apos;users&apos;); store.add(&#123; username: &quot;007&quot;, firstName: &quot;James&quot;, lastName: &quot;Bond&quot;, password: &quot;foo&quot;&#125;);&#125;//因为这里要调用onsucess时候保存的db的实例，但是因为异步操作，如果不用超时调用，可能db还没有获取到！setTimeout(function() &#123; updataData();&#125;,500); 先测试将键值为”007”的对象的firstName属性改为jack结果然后来删除键值为”007”的对象代码 123setTimeout(function() &#123; deleteData(&quot;007&quot;);&#125;,500); 结果删除成功 测试添加功能 123setTimeout(function() &#123; addData();&#125;,500); 结果 好了，现在创建数据库，给数据库存内容，实现了基本的增删改查。下面介绍游标查询 使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。 在对象存储空间上调用openCursor()方法可以创建游标。与IndexedDB中的其他操作一样，openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理程序。 代码 123456789101112//打开游标function openCursor() &#123; var store = db.transaction(&quot;users&quot;).objectStore(&quot;users&quot;); var request = store.openCursor(); request.onsuccess = function() &#123; var cursor = event.target.result; if (cursor) &#123; console.log(cursor.key); cursor.continue(); &#125; &#125;; &#125; 测试 键范围使用游标总让人觉得不那么理想，因为通过游标查找数据的方式太有限了。键范围（Keyrange）为使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。 有四种定义键范围的方式。1. 第一种是使用only()方法，传入你想要取得的对象的键 var onlyRange = IDBKeyRange.only(&quot;007); 2. 第二种定义键范围的方式是指定结界集的下界 var lowerRange = IDBKeyRange.lowerBound(&quot;007&quot;);` 如果你想忽略键为&quot;007&quot;的对象，从它的下一个对象开始，那么可以传入第二个参数true； 3.第三种定义键范围的方式是指定结界集的上界 var lowerRange = IDBKeyRange.upperBound(&quot;ace&quot;); 如果你不想包含键为指定值的对象，同样，可以传入第二个参数true 4.第四种定义键范围的方式，就是同时指定上、下界。使用bound()方法。这个方法可以接受4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过上界的布尔值。 索引（后续补充）补充说明：我是在高程书上学的indexedDB,其中有一处问题，新版本的IndexedDB规范不支持调用setVersion()方法为数据库指定一个版本号，代替的方法是在open()的时候结合传入表示版本号的字符串，同时使用onupgradeneeded事件代替setVersion()方法。onupgradeneeded事件会在onsuccess之前被调用 还有就是游标查询的更新和删除出现问题，我还未解决，所以不做示例。（因为是很多都是用自己理解的方式解释，有不严谨的地方，望谅解） IndexedDB的其他解释博客 谦行大牛博客 张鑫旭大牛博客 范圣刚博客]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>indexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimeText3配置]]></title>
    <url>%2F2017%2F11%2F09%2FsublimeText3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[遥不可及的并非十年之后，而是今天之前。 首先从官网下载sublime Text3软件，sublime Text3下载下来之后破解，注册码如下—– BEGIN LICENSE —–TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB—— END LICENSE —— 注册码使用方式菜单栏里的Help点击License然后输入如上注册码回车即可我的默认Preferences中setting为 123456789101112131415&#123; &quot;auto_close_tags&quot;: true, &quot;auto_complete&quot;: true, &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.tmTheme&quot;, &quot;expand_tabs_on_save&quot;: true, &quot;font_size&quot;: 20, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;tab_size&quot;: 4, &quot;theme&quot;: &quot;Adaptive.sublime-theme&quot;, &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: true&#125; 安装插件管理的Package Control打开View中的console（ctrl+`）然后输入如下代码 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 回车即可 我安装的插件 Emmet、less、sass、]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>sublimeText3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQuery-jQuery对象]]></title>
    <url>%2F2017%2F11%2F09%2F%E9%94%8B%E5%88%A9%E7%9A%84jQuery-jQuery%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。 JavaScript库作用及对比 Prototype Prototype是的JavaScript库之一，对JavaScript的内置（String对象、Array等）做了大量的扩展。现在还有很多项目使用Prototype。Prototype可以看是好的、有用的JavaScript的组合在一起而形成的JavaScript库。使用者可以在需要的时候随时将其中的几段代码抽出来放进自己的脚本里。但是由于Prototype成型年代早，从整体上对于面向对象的编程思想把握不是很到位，导致了其结构的松散，不过现在Prototype也在慢慢改进。 Dojo Dojo的强大之处在于Dojo提供了很多其他JavaScript库所没有提供的功能。例如离线存储API、生成图标的组件、基于SVG/VML的矢量图形库和Comet支持等等。Dojo是一款非常适合企业级应用的JavaScript库、并且得到了IBM、SUN和BEA等一些大公司的支持。但是Dojo的缺点也是很明显的：学习曲线陡，文档不齐全。最严重的就是API不稳定。每次升级都可能导致已有的程序失效，但是自从Dojo的1.0.0版出现以后，情况有所好转，Dojo还是一个很有发展潜力的库。 YUI YUI是有Yahoo公司开发的一套完备的、扩展性良好的富交换网页程序工具集。YUI封装了一系列比较丰富的功能。例如DOM操作和Ajax应用等，同时还包括了几个核心的CSS文件。该库本身文档及其完备，代码编写也非常规范。 Ext JS Ext JS常简称为Ext，原本是对YUI的一个扩展，主要用于创建前端用户界面，如今已经发展到可以利用包括jQuery在内的多种JavaScript框架作为基础库，而Ext作为界面的扩展库来使用。Ext可以用来开发富有华丽外观的富客户端应用，能使B/S应用更加具有活力。但是由于Ext侧重于界面，本身比较臃肿，所以使用之前先权衡利弊。另外，需要注意的是，Ext并非完全免费，如果用于商业用途，需要付费获得授权许可。 MooTools MooTools是一套轻量、简介、模块化和面对对象的JavaScript框架。MooTools的语法几乎跟Prototype一样，但却提供了更为强大的功能、更好的扩展性和兼容性。其模块化思想非常优秀，核心代码大小只有8KB.无论用到哪个模块都可即时导入，即时是完整版大小也不超过160KB.MooTools完全彻底的面向对象的编程思想。语法简介直观，文档完善，是一个非常不错的JavaScript库。 jQuery jQuery同样是一个轻量级的库，拥有强大的选择器，出色的DOM操作，可靠的事件处理、完善的兼容性和链式操作等优点。 jQuery的优势： 轻量级 强大的选择器 出色的DOM操作的封装 可靠的事件处理机制 完善的Ajax 不污染顶级变量 出色的浏览器兼容性 链式操作方式 隐式迭代 行为层与结构层的分离 丰富的插件支持 完善的文档 window.onload和$(document).ready(）的对比 区别 window.onload $(document).ready 执行时机 必须等待网页中所有的内容加载完毕后（包括图片）才能执行 网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完 编写个数 不能同时编写多个一下代码无法正常执行: window.onload = function() { alert(&quot;test1&quot;)}; window.onload = function() {alert(&quot;test2&quot;);结果只会输出”test2” 能同时编写多个一下代码正确执行：$(document).ready(function() {alert(&quot;Hello world!&quot;)}); $(document).ready(function() {alert(&quot;Hello again!&quot;)});结果两次都输出 简化写法 无 可以简写成：$(function(){//…}); jQuery对象jQuery对象就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法。例如 1$(&quot;#foo&quot;).html(); //获取id为foo的元素内的html代码。.html（）是jQuery里的方法 这段代码等同于： 1document.getElementById(&quot;foo&quot;).innerHTML; 在jQuery对象中无法使用DOM对象的任何方法。 jQuery对象和DOM对象的相互转换1.jQuery对象转成DOM对象（1） var $cr = $(&quot;#cr&quot;); //jQuery对象 var cr = $cr[0]; //DOM对象 （2） var $cr = $(&quot;#cr&quot;);//jQuery对象 var cr = $cr.get(0);//DOM对象 2.DOM对象转成jQuery对象 var cr = document.getElementById(&quot;cr&quot;);//DOM对象 var $cr = $(cr);//jQuery对象 解决jQuery和其他库的冲突 jQuery库在其他库之后导入 jQuery库在其他库之前导入]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display:none的验证]]></title>
    <url>%2F2017%2F11%2F03%2Fdisplay-none%E7%9A%84%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[我的世界会有一束光，而我永远都会在最初的地方等它。 display：none；的验证结果是该元素所占空间消失，验证例子为：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width:500px; height:500px; &#125; .num1&#123; background:#000; /*display: none;*/ &#125; .num2&#123; background:blue; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;num1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;num2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果：display设置为none后证明结果：display设置为none时，所占空间消失。但是发现给第二个块元素设置为display为inline-block时并没有与第一个块元素在一行，所以将第一个块元素的display也设置为inline-block时，两个块元素才处于一行。然后想起之前有看过块元素可以和行内元素处于一行，就试了下div后插一个a标签结果： 123&lt;div class=&quot;num1&quot;&gt;&lt;/div&gt;&lt;a href=&quot;###&quot;&gt;111&lt;/a&gt;&lt;div class=&quot;num2&quot;&gt;&lt;/div&gt; 效果：然后去查了下之前行内元素和块元素的概念和相关知识： 行内元素与块元素行内元素也叫内联元素，块元素有点也叫行元素。 行级元素和块级元素 元素是通过display的属性值来划分的：block块元素 inline行内元素 inline-block行内块元素 块级元素具有以下特点：1.总是新行上开始，占据一整行； 2.高度，行高以及外边距和内边距都可控制； 3.宽在未设置情况下与浏览器的宽度一样，与内容无关； 4.它可以容纳内联元素和其他块元素。 行内元素的特点：1.和其他元素都在一行上； 2.内联元素不可以设置宽和高、垂直的margin和padding ！！ 3.宽度只与内容有关； 4.行内元素只能容纳文本和其他行内元素。 元素类型 独占一行 能设置宽高 margin,padding值 块级元素 是 是 四个都可以设置 内联元素 否 否 竖直的不可设置 在查询资料的时候有发现了一个东西就是 p元素内不能嵌套div元素 然后我去做了试验： 1&lt;p&gt;1111&lt;div&gt;222&lt;/div&gt;333&lt;/p&gt; 效果如下：然后查询相关解释：为什么p元素不能嵌套div元素 p元素有默认样式！最好设置margin：0；padding：0； 然后又想到文档流这个概念：html文档流： 自窗体自上而下分成一行一行，并在每行中按从左到右的顺序排放元素。 拓展：inlne-block有几像素的误差！！！ 语义化的好处：1.去掉或样式丢失的时候能让页面呈现清晰的结构。 2.搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。 3.便于团队开发和维护。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css学习笔记]]></title>
    <url>%2F2017%2F10%2F14%2Fhtml-css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[人生是一场错过,愿你别蹉跎。 css选择器：基础选择器、关系选择器、属性选择器、伪类选择器、伪对象选择器。 关系选择器有如下几种： 包含选择器（EF） 子选择器（E&gt;F） 相邻选择器（E+F） 兄弟选择器（E~F）注意的地方，对它后面的元素起作用。 1.包含选择器符（EF）选择所有被E元素包含的F元素，中间用空格隔开。 12345678ul li&#123; color:red;&#125;&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橙子&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ul&gt; 2.子选择器符（EF）选择所有作为E元素的直接子元素F，对更深一层的元素不起作用，用大于号表示。 12345div&gt;a&#123; color:red; //div下的一级子元素a&#125;&lt;a href=&quot;#&quot;&gt;这是子元素&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;这是子孙元素&lt;/a&gt;&lt;/p&gt; 选择第一个子元素，在bootstrap的源码非常多见。 3.相邻选择器符（E+F）选择紧贴在E元素之后F元素，用加号表示，选择相邻的第一个兄弟元素。 123456p+span&#123; color:red; //只会选中第一个span&#125;&lt;p&gt;这是p元素&lt;/p&gt;&lt;span&gt;这是紧挨着p元素的第一个span&lt;/span&gt;&lt;span&gt;这是第二个span&lt;/span&gt; 4.兄弟选择器符（E~F）选择E元素之后的所有兄弟元素F，作用于多个元素，用~号隔开。 12345678p+span&#123; color:red; //和p之后平级的span元素都被选中了，有几个选几个。&#125;&lt;span&gt;这span在p元素之前不会被选中。&lt;/span&gt;&lt;p&gt;这是p元素&lt;/p&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt;&lt;span&gt;~~~~~~~~&lt;/span&gt; css属性选择器通过html的属性来选择元素，&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;class即是属性，p1是class的属性值。 写法：元素[属性名=&quot;属性值&quot;]，等号不固定，可换其他符号。 E[att] 选择具有att属性的E元素 E[att=”val”] 选择具有att属性且属性值等于val的E元素 E[att~=”val”] 选择有att属性的元素，且属性值列表中有一个符号val E元素。 E[att^=”val”] 选择E元素中有att属性，且以”val”开头的E元素。 E[att$=”val”] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=”val”] 选择具有att属性且属性值包含val的字符串的E元素。 伪类选择器伪类通过冒号来定义，它定义了元素的状态，如点击按下，点击完等等，我们之前都是直接操作元素的样式，使元素看上去更&quot;动态&quot;。 E:link 设置超链接a在未被访问前的样式（特指a标签） E:visited 设置超链接a已被访问过的样式（特指a标签） E:hover 设置鼠标悬浮在元素上时的样式，不限于a标签 E:active 设置元素在鼠标按下时的样式，不限于a标签 E:not(s) 匹配不含有s选择器的元素 E:first-child 父元素的第一个子元素 E:last-child only-child empty checked nth-child(n) 伪对象选择器伪对象也叫伪元素，在过去，伪类和伪元素都被写成前面只加一个冒号，实际上应该:weilei ::weiyuansu，而现在我们为了兼容旧的书写方式，用一个冒号引导伪类也是能被解析的。 伪类一般反映无法在css中轻松或者可靠检测到的某个元素的状态或属性； 伪元素表示DOM外部的某种文档结构 伪类更多是定义元素的状态，而伪元素是改变文档结构，在结构外另加一个没有实际存在的元素（伪元素） 常用伪元素（html之外通过css模拟出一个html结构） 1.E:before/E::before 2.E:after/E::after position定位 position属性是指本体相对于上级的定位，position定位又分绝对定位和相对定位。它的默认值是static，意味着元素没有定位，出现在文档流中应该出现的位置。如果用position来布局页面，父级元素的position属性必须为relative或absolute，行元素加了position:absolute后可设置宽和高（加了float和fixed以后也可以设置宽和高） 常见属性值： static：无特殊定位，对象遵循正常文档流。 relative：对象遵循正常文档流。 absolute：对象脱离正常文档流，使用top、right、bottom、left等属性进行绝对定位。 fixed：对象脱离正常文档流。使用top、right、bottom、left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。IE6及以下不支持此参数值。 static、relative正常文档流 absolute、fixed脱离正常文档流 position绝对定位。设置了绝对定位的元素，他默认参照浏览器的左上角，配合top、right、bottom、left四个属性进行定位。通常我们设置两个值就可以定位，如果四个都写，以左上角（left、top）为准。 清除浮动的三个方法：1.使用伪元素清除浮动123456789101112131415.box::after&#123; content:&quot; &quot;; clear:both; display:block;&#125;.left,.right&#123; width:100px; height:100px; background:#388bff; float:left;&#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 2.使用overflow：hidden清除浮动12345678910111213.box&#123; overflow:hidden; //overflow:auto 也是可以的&#125;.left,.right&#123; width:100px; height:100px; background:#388bff; float:left;&#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 3.使用空div1234.clear&#123; clear:both;&#125;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 能被继承的常用属性：color、cursor、font-family、font-size、font-weight、font、letter-spacing、line-height、list-style、text-align、text-indent 浏览器内核以及其前缀 Gecko内核 前缀为-moz- 火狐浏览器 Webkit内核 前缀为-webkit- chrome浏览器、safari浏览器 Trident内核 前缀为-ms- 也称IE内核 Presto内核 前缀为-o- 只有opera采用，但现在opera使用了有webkit衍生在blink内核 box-shadow：水平阴影的位置 垂直阴影的位置 模糊距离 颜色box-shadow:10px 20px 5px blue; text-shadow(文字阴影)格式同上 css3字体 引用 1234@font-face&#123; font-family:myFirstFont; //你自定义的字体名 src:url(&quot;res/lxksf.ttf&quot;);&#125; 过渡transition书写格式 transition:属性名 时间 速度曲线 何时开始; 最少要包含过渡时间。 转换transform分为2D和3D 2D transform:rotate(0 deg); 3D transform:rotateX(); transform:rotateY(); transform:rotate3d(x,y,z); //z轴一般不用写 动画@keyframes动画名 两种方式1.form to 2.百分比 用@keyframes定义好后通过animation进行引用 animation的可选值可指定这几个值:动画名、动画时长、效果、开始时间 动画示例： 1234567891011121314151617img&#123; width:100px; height:100px; border-radius:50%;&#125;@keyframes CDturn&#123; from&#123; transform:rotate(0 deg); &#125; to&#123; transform:rotate(360 deg); &#125;&#125;img:hover&#123; animation:3s linear infinite CDturn&#125;&lt;img src=&quot;img/cd.png&quot; alt=&quot; &quot; /&gt; 特殊图形三角形 通过border来定义，宽和高要设置为0，另外两面的颜色设置为透明 梯形 通过border来定义，和三角形不同的是要设置宽度。 圆形 宽、高、border-radius：50%; 多列column-count 分几列 column-gap 列间距 column-rule 列分割线的样式 （加前缀:eg；-webkit-） 多行文本框1&lt;textarea name=&quot; &quot; id=&quot; &quot; cols=&quot;30&quot; row=&quot;10&quot;&gt;&lt;/textarea&gt; 补充：resize=none;（不可调大小）模拟出可调大小的： resize:both; overflow:hidden; width:_px; height:_px; border:_ _ _; Box-sizingbox-sizing属性允许你以&quot;W3C的盒模型&quot;或&quot;IE盒模型&quot;来定义元素，以适应区域。换句话说，当前元素使用哪种盒模型，可以由box-sizing属性指定。 它有两个值 content-box（标准） ：padding和border不被包含在width和height内，元素的实际大小为宽高+border+padding，此为标准模型下的盒模型。 border-box（怪异）：padding和border被包含在定义的width和height中，元素实际的大小为你定义了多宽就是多宽。此属性为怪异模式下的盒模型。 meta标签的常用属性http-equiv属性refresh，它指定时间内刷新，并且可能跳转到指定url&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;url=http://www.baidu.com&quot;/&gt;如果只写时间。自动刷新本页面 ####img标签边距问题解决方法 把img标签转化为块元素。 父容器指定高度。 父容器的字号变为font-size：0px; (注意里面的字号要另外设置)]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于响应式网站做的笔记]]></title>
    <url>%2F2017%2F10%2F13%2F%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E7%AB%99%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[既然选择远方，便只顾风雨兼程。 响应式网站是一个设计理念，它是多项技术的综合体流动网格（弹性网格布局）、弹性图片和媒介查询是响应式互联网设计的三大技术成分优点： 解决了设备只见的差异化展示（让不同的设备达到最优的视觉体验） 减少工作量1、网站、设计、代码、内容都只需要一份 2、多出来的工作量只是JS脚本、CSS样式做一些改动 节省时间 每个设备都能得到正确的设计 搜索优化缺点： 会加载更多的样式和脚本资源 设计比较难精确定位和控制 老版本浏览器兼容不好设计实践原则 progressive enhancement 渐进增强 （不适用） graceful degradation 优雅降级（更好）移动优先： 在设计的初期就要考虑的页面如何在多终端展示断点的选择：0-480（小屏幕）、 481-800（中屏幕）、 801-1400（大屏幕）、 1400+（巨屏幕） 移动webPixel 移动开发像素知识px：css pixels 逻辑像素，浏览器使用的抽象单位 dp,pt:device independent pixels 设备无关像素 dpr:devicePixelRatio 设备像素缩放比 计算公式: 平面上：1px = (dpr)^2 * dp 纬度上：1px = dpr * dp DPI:打印机每英寸可以喷的墨汁点（印刷行业） PPI：屏幕每英寸的像素数量，即单位英寸内的像素密度 PPI越高，像素数越高，图像越清晰，但可视度越低（小），系统默认设置缩放比越大 Retina（高清屏）: dpr都是大于等于2]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass学习笔记]]></title>
    <url>%2F2017%2F10%2F13%2FSass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我的世界会有一束光，而我永远都会在最初的地方等它。亦如最初的自己 Sass:定义：css预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为css增加了一些编程的特性，将css作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。（采用RuBy语言编写的一款css预处理语言） 扩展名：.sass(严格的缩进式语法) .scss（与平时css语法书写类似） scss和css写法无差别，这也是Sass后来越来越受大众喜欢原因之一。 Sass编译 方法： 命令编译（我喜欢） GUI工具编译 自动化编译（Grunt和Gulp） 命令编译： 单文件编译 sass（要编译的Sass文件路径）/style.scss:（要输出css文件路径）/style.css 多文件编译 sass sass/:css/ 上面的命令表示将项目中的&quot;sass&quot;文件夹中所有&quot;.scss&quot;(&quot;.sass&quot;)文件编译成&quot;.css&quot;文件，并且将这些css文件都放在项目&quot;css&quot;文件夹中。 开启”watch”功能，这样只要你的代码进行任何修改，都能自动监测到代码的变化，并且给你直接编译出来： sass --watch （要编译的Sass文件路径）/style.scss:（要输出css文件路径）/style.css Sass常见的编译错误 字符编码引起的（不支持”GBK”编码，设置为”UTF-8”） 路径中的中文字符（不要使用中文字符命名文件目录名） 不同样式风格的输出方法：1.嵌套输出方式 nested 2.展开输出方式 expanded 命令行最后加 -- style expanded 3.紧凑输出方式 compact 4.压缩输出方式 compressed Sass普通变量与默认变量普通变量：定义之后可以在全局范围内使用。 默认变量：sass的默认变量仅需要在值后面加上！default即可。 （Sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，只需要在默认变量之前重新声明下变量即可。）默认变量的价值在进行组件化开发的时候会非常有用。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记]]></title>
    <url>%2F2017%2F10%2F12%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我爱你，不光是因为你的样子，还因为和你在一起时我的样子。我爱你，不光是因为你为我做的是，还因为为了你我能做的事。 ECMAScript篇：defer属性和async属性只适用于外部脚本文件ECMAScript中的一切（变量、函数名、和操作符）都区分大小写。标识符：就是指变量、函数、属性的名字或者函数的参数。按照惯例ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩余的每个单词的首字母大写。要在整个脚本中启用严格模式，可以在顶部添加如下代码：&quot;use strict&quot;(这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示，用于告诉支持的JavaScript引擎切换到严格模式) ECMAScript中的5种简单数据类型：Undefined、Null、Boolean、Number和String.复杂数据类型：Object（本质名值对）null表示一个空对象指针（如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值）浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数12345var a = 0.1;var b = 0.2;if (a + b == 0.3) &#123; //不要做这样的测试! alert(&quot;You got 0.3.&quot;);&#125; 但以下代码ok 12345var a = 0.05;var b = 0.25;if (a + b == 0.3) &#123; alert(&quot;You got 0.3.&quot;);&#125; NaN与任何值都不相等，包括NaN本身。1alert(NaN == NaN); //false 用parseInt()转换空字符串会返回NaN 字符串要理解的点：ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，**首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量**。 一元操作符中要注意的（前置和后置）执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。 1234var age = 29;var anotherAge = --age + 2;alert(age); // 输出28alert(anotherAge); //输出30 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。 1234var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //等于22var num4 = num1 + num2; //等于21 在随后的学习中，学习js数据结构列表时，看到一个后置的一元操作符，瞬间觉得这种前置和后置设计的伟大之处。1234/* 给列表添加元素 */function append(element)&#123; this.dataStore[this.listSize++]=element;&#125; 我对这个函数的理解：给当前数组位置存一个新值，然后数组的长度加一，既赋值了当前项，又为下一项的保存预先留个空位。（仅个人理解，如有问题，感谢指出） 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。逻辑或操作符是短路操作符，如果第一个操作数的求值结果为true，就不会对第二个操作数求值。这种可以用于给某变量赋值：（妙用如下） 1var myObject = preferredObject || backupObject; 我的理解：为了让某个变量赋值的保险起见，一般逻辑或前面的基本都会存在，如果不存在，为其赋值后面一个，加个保险。（仅个人理解，如有问题，感谢指出） 相等操作符：注意“==”和“===”记住：null == undefined会返回true,因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。 break和continue语句 break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。 switch语句在比较值时使用的是全等操作符，因此不会发生类型转换。ECMAScript中所有函数的参数都是按值传递的。使用var声明的变量会自动被添加到最接近的环境中。优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用—这个做法叫做解除引用。（解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收）基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中; 引用类型的值是对象，保存在堆内存中; 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符 instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 为了解决这个问题，ECMAScript5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是哪个全局执行环境中创建的。这个方法的用法如下： 123if (Array.isArray()) &#123; //对数组执行某些操作&#125; 函数名仅仅是指向函数的指针。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。BOM篇（HTML5规范）top对象始终指向最高（最外）层的框架，也就是浏览器窗口。判断页面是否处于标准模式document.compatMode == &quot;CSS1Compat&quot; 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。JavaScript是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。所以，最好不要使用间歇调用。 DOM篇NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。我们常说，NodeList是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。由于IE没有公开Node类型的构造函数，为了确保跨浏览器兼容，最好还是将nodeType属性与数字值进行比较。appendChild()、insertBefore()、replaceChild()、removeChild()这四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用parentNode属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用这些方法，将会导致错误。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网深入理解笔记]]></title>
    <url>%2F2017%2F10%2F12%2F%E6%85%95%E8%AF%BE%E7%BD%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[只要你努力，你要的，岁月都会给你。 CSS深入理解之border：border-width不支持百分比 border-width支持关键字：thin(1px),medium(默认值3px),thick(5px) border-style:solid(实线)、dashed（虚线）、dotted（点线）(IE7、IE8圆角)、double(双线)（三道杠图标）、inset(内凹)、groove(沟槽)、ridge（山脊） 当没有指定border-color的时候，会使用color作为边框色！ CSS深入理解之z-index: 含义：z-index属性指定了元素及其子元素的[z顺序]，而[z顺序]可以决定当元素发生覆盖的时候，哪个元素在上面。通常一个较大z-index值的元素会覆盖较低的那一个。 属性值： ·z-index:auto; 默认值 ·z-index:&lt;integer&gt;; 整数值 ·z-index:inherit; 继承 基本特性： 1、支持负值； 2、支持CSS3 animation动画； 3、在CSS 2.1时代，需要和定位元素配合使用； 如果不考虑CSS3，只有定位元素（position:relative/absolute/fixed/sticky）的z-index才有作用！在CSS3中有例外... 前提：z-index值是数值，非auto！ 如果定位元素z-index没有发生嵌套： 1、后来居上的原则； 2、哪个大，哪个上； 如果定位元素z-index发生嵌套： 祖先优先原则； 层叠上下文：HTML元素中的一个三维概念，表示元素在z轴上有了&quot;可以高人一等&quot; ·页面根元素天生具有层叠上下文，称之为&quot;根层叠上下文&quot;。 ·z-index值为数值的定位元素也具有层叠上下文。 ·其他属性... 层叠水平：层叠上下文中的每个元素都有一个层叠水平，决定了同一个层叠上下文中元素在z轴上的显示顺序。遵循&quot;后来居上&quot;和&quot;谁大谁上&quot;的层叠准则。 ·层叠上下文可以嵌套，组合成一个分层次的层叠上下文。 ·每个层叠上下文和兄弟元素独立：当进行层叠变化或渲染的时候，只需要考虑后代元素。 ·每个层叠上下文是自成体系的：当元素的内容被层叠后，整个元素被认为是在父层的层叠顺序中。 层叠顺序：元素发生层叠时候有着特定的垂直显示顺序。 （著名的7阶层叠水平） 层叠上下文background/border&lt;负z-index&lt;block块状水平盒子&lt;float浮动盒子&lt;inline/inline-block水平盒子&lt;z-index:auto或看成z-index:0(不依赖z-index的层叠上下文)&lt;正z-index z-index的实际行为表现： 1.定位元素默认z-index:auto可以看成是z-index:0; 2.z-index不为auto的定位元素会创建层叠上下文； 3.z-index层叠顺序的比较止步于父级层叠上下文； 其他参与层叠上下文的属性们 1.z-index值不为auto的flex项（父元素display:flex|inline-flex）. 2.元素的opacity值不是1. 3.元素的transform值不是none. 4.元素mix-blend-mode值不是normal. 5.元素的filter值不是none. 6.元素的isolation值是isolate. 7.position:flexd声明 8.will-change指定的属性值为上面任意一个。 9.元素-webkit-overflow-scrolling设为touch. （1.不支持z-index的层叠上下文元素的层叠顺序均是z-index：auto级别 2.依赖z-index的层叠上下文元素的层叠顺序取决于z-index值） ·z-index相关实践分享 1.最小化影响原则 2.不犯二准则 3.组件层级计数器 4.可访问性隐藏]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin-top的问题]]></title>
    <url>%2F2017%2F10%2F12%2Fmargin-top%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[眼为视而生，则美为美而在。 一个div内嵌套一个div，如果给内部div设置margin-top，理论上，外部div位置不变，内部div相对向下移动。（但有个前提是，外部的div未设置border和padding）未设置margin-top的情况：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;margin-top的问题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0px; padding: 0px; &#125; .outside&#123; width:200px; height:200px; background-color: blue; &#125; .inside&#123; /*margin-top:20px;*/ width:100px; height:100px; background-color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outside&quot;&gt; &lt;div class=&quot;inside&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在把magrin-top的注释取消：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;margin-top的问题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin:0px; padding: 0px; &#125; .outside&#123; width:200px; height:200px; background-color: blue; &#125; .inside&#123; margin-top:20px; width:100px; height:100px; background-color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outside&quot;&gt; &lt;div class=&quot;inside&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 理论上应该是下面这种情况：这个问题我在5大主浏览器上试过，发现均出现这种情况：然后上网查询，找到了一段对这个描述最清楚的解释。 父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding.就会不断一层一层的找自己“领导”(父元素，祖先元素)的麻烦。解决办法如下：1.给外部div设置border-bottom:0.1px solid #000; 2.或者设置padding-bottom:0.1px; 3.给设置maigin-top的div设置overflow:hidden.]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
